/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	function webpackJsonpCallback(data) {
/******/ 		var chunkIds = data[0];
/******/ 		var moreModules = data[1];
/******/ 		var executeModules = data[2];
/******/
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId]) {
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			}
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(data);
/******/
/******/ 		while(resolves.length) {
/******/ 			resolves.shift()();
/******/ 		}
/******/
/******/ 		// add entry modules from loaded chunk to deferred list
/******/ 		deferredModules.push.apply(deferredModules, executeModules || []);
/******/
/******/ 		// run deferred modules when all chunks ready
/******/ 		return checkDeferredModules();
/******/ 	};
/******/ 	function checkDeferredModules() {
/******/ 		var result;
/******/ 		for(var i = 0; i < deferredModules.length; i++) {
/******/ 			var deferredModule = deferredModules[i];
/******/ 			var fulfilled = true;
/******/ 			for(var j = 1; j < deferredModule.length; j++) {
/******/ 				var depId = deferredModule[j];
/******/ 				if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 			}
/******/ 			if(fulfilled) {
/******/ 				deferredModules.splice(i--, 1);
/******/ 				result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 			}
/******/ 		}
/******/ 		return result;
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// Promise = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"/js/app": 0
/******/ 	};
/******/
/******/ 	var deferredModules = [];
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/Users/rhys/Desktop/Projects/git-repositories/HPOExperiment/public/assets/js";
/******/
/******/ 	var jsonpArray = window["webpackJsonp"] = window["webpackJsonp"] || [];
/******/ 	var oldJsonpFunction = jsonpArray.push.bind(jsonpArray);
/******/ 	jsonpArray.push = webpackJsonpCallback;
/******/ 	jsonpArray = jsonpArray.slice();
/******/ 	for(var i = 0; i < jsonpArray.length; i++) webpackJsonpCallback(jsonpArray[i]);
/******/ 	var parentJsonpFunction = oldJsonpFunction;
/******/
/******/
/******/ 	// add entry module to deferred list
/******/ 	deferredModules.push([0,"/js/vendor"]);
/******/ 	// run deferred modules when ready
/******/ 	return checkDeferredModules();
/******/ })
/************************************************************************/
/******/ ({

/***/ "./assets/js/app.js":
/*!**************************!*\
  !*** ./assets/js/app.js ***!
  \**************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"./node_modules/react-dom/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var HPO_containers_App__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! HPO/containers/App */ \"./assets/js/containers/App.jsx\");\n/**\n * app.js\n *\n * This is the entry file for the application, only setup and boilerplate\n * code.\n */\n// Import all the third party stuff\n\n // Import root app container\n\n\nvar WRAPPER = 'app'; // Render application\n\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n  var MOUNT_NODE = document.getElementById(WRAPPER);\n\n  if (MOUNT_NODE !== null) {\n    react_dom__WEBPACK_IMPORTED_MODULE_1___default.a.render(react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(HPO_containers_App__WEBPACK_IMPORTED_MODULE_2__[\"default\"], null)), MOUNT_NODE);\n  }\n});\n\n//# sourceURL=webpack:///./assets/js/app.js?");

/***/ }),

/***/ "./assets/js/classes/player.jsx":
/*!**************************************!*\
  !*** ./assets/js/classes/player.jsx ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Player =\n/*#__PURE__*/\nfunction () {\n  function Player(genome, x, y, w, h) {\n    _classCallCheck(this, Player);\n\n    this.x = x;\n    this.y = y;\n    this.vx = 0;\n    this.vy = 0;\n    this.r = 6;\n    this.WIDTH = w;\n    this.HEIGHT = h;\n    this.MAX_SPEED = 5;\n    this.SCORE_RADIUS = 100;\n    this.brain = genome;\n    this.brain.score = 0;\n  }\n\n  _createClass(Player, [{\n    key: \"update\",\n    value: function update() {\n      var input = this.detect();\n      var output = this.brain.activate(input);\n      var moveangle = output[0] * 2 * window['p'].PI; // Calculate next position\n\n      this.ax = Math.cos(moveangle);\n      this.ay = Math.sin(moveangle);\n      this.vx += this.ax;\n      this.vy += this.ay; // Limit speeds to maximum speed\n\n      this.vx = this.vx > this.MAX_SPEED ? this.MAX_SPEED : this.vx < -this.MAX_SPEED ? -this.MAX_SPEED : this.vx;\n      this.vy = this.vy > this.MAX_SPEED ? this.MAX_SPEED : this.vy < -this.MAX_SPEED ? -this.MAX_SPEED : this.vy;\n      this.x += this.vx;\n      this.y += this.vy; // Limit position to width and height\n\n      this.x = this.x >= this.WIDTH ? this.WIDTH : this.x <= 0 ? 0 : this.x;\n      this.y = this.y >= this.HEIGHT ? this.HEIGHT : this.y <= 0 ? 0 : this.y;\n\n      if (this.x === 0 || this.x === this.WIDTH) {\n        this.vx = -this.vx;\n      }\n\n      if (this.y === 0 || this.y === this.HEIGHT) {\n        this.vy = -this.vy;\n      }\n\n      this.score();\n    }\n    /**\n     * Calculate fitness of this players genome\n     */\n\n  }, {\n    key: \"score\",\n    value: function score() {\n      var dist = window['p'].distance(this.x, this.y, window['walker'].x, window['walker'].y);\n\n      if (!isNaN(dist) && dist < this.SCORE_RADIUS) {\n        this.brain.score += this.SCORE_RADIUS - dist;\n      } // Replace highest score to visualise\n\n\n      window.highestScore = this.brain.score > window.highestScore ? this.brain.score : window.highestScore;\n    }\n    /**\n     * Display the player on the field, parts borrowed from the CodingTrain\n     */\n\n  }, {\n    key: \"show\",\n    value: function show() {\n      // Draw a triangle rotated in the direction of velocity\n      var angle = window['p'].angleToPoint(this.x, this.y, this.x + this.vx, this.y + this.vy) + window['p'].HALF_PI;\n      var color = window['p'].activationColor(this.brain.score, window.highestScore);\n      window['p'].push();\n      window['p'].translate(this.x, this.y);\n      window['p'].rotate(angle);\n      window['p'].fill(color);\n      window['p'].beginShape();\n      window['p'].vertex(0, -this.r * 2);\n      window['p'].vertex(-this.r, this.r * 2);\n      window['p'].vertex(this.r, this.r * 2);\n      window['p'].endShape(window['p'].CLOSE);\n      window['p'].pop();\n    }\n    /**\n     * Detect and normalize inputs\n     */\n\n  }, {\n    key: \"detect\",\n    value: function detect() {\n      var dist = Math.sqrt(this.x, this.y, window['walker'].x, window['walker'].y) / Math.sqrt(Math.pow(this.WIDTH, 2) + Math.pow(this.HEIGHT, 2));\n      var targetAngle = window['p'].angleToPoint(this.x, this.y, window['walker'].x, window['walker'].y) / window['p'].TWO_PI;\n      var vx = (this.vx + this.MAX_SPEED) / this.MAX_SPEED;\n      var vy = (this.vy + this.MAX_SPEED) / this.MAX_SPEED;\n      var tvx = (window['walker'].vx + this.MAX_SPEED) / this.MAX_SPEED;\n      var tvy = (window['walker'].vy + this.MAX_SPEED) / this.MAX_SPEED; // NaN checking\n\n      targetAngle = isNaN(targetAngle) ? 0 : targetAngle;\n      dist = isNaN(dist) ? 0 : dist;\n      return [vx, vy, tvx, tvy, targetAngle, dist];\n    }\n  }]);\n\n  return Player;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Player);\n\n//# sourceURL=webpack:///./assets/js/classes/player.jsx?");

/***/ }),

/***/ "./assets/js/classes/walker.jsx":
/*!**************************************!*\
  !*** ./assets/js/classes/walker.jsx ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Walker =\n/*#__PURE__*/\nfunction () {\n  function Walker(x, y) {\n    _classCallCheck(this, Walker);\n\n    this.x = x;\n    this.y = y;\n    this.vx = 0;\n    this.vy = 0;\n    this.WIDTH = 900;\n    this.HEIGHT = 500;\n    this.MAX_SPEED = 5;\n    this.SCORE_RADIUS = 100;\n    this.r = 10;\n    this.angle = Math.random() * Math.PI * 2;\n  }\n\n  _createClass(Walker, [{\n    key: \"update\",\n    value: function update() {\n      if (Math.random() > 0.5) {\n        this.angle += Math.random() * 2 - 1;\n      } // Calculate next position\n\n\n      this.ax = Math.cos(this.angle);\n      this.ay = Math.sin(this.angle);\n      this.vx += this.ax;\n      this.vy += this.ay; // Limit speeds to maximum speed\n\n      this.vx = this.vx > this.MAX_SPEED / 2 ? this.MAX_SPEED / 2 : this.vx < -this.MAX_SPEED / 2 ? -this.MAX_SPEED / 2 : this.vx;\n      this.vy = this.vy > this.MAX_SPEED / 2 ? this.MAX_SPEED / 2 : this.vy < -this.MAX_SPEED / 2 ? -this.MAX_SPEED / 2 : this.vy;\n      this.x += this.vx;\n      this.y += this.vy; // Limit position to width and height\n\n      this.x = this.x >= this.WIDTH ? this.WIDTH : this.x <= 0 ? 0 : this.x;\n      this.y = this.y >= this.HEIGHT ? this.HEIGHT : this.y <= 0 ? 0 : this.y;\n\n      if (this.x === 0 || this.x === this.WIDTH) {\n        this.vx = -this.vx;\n        this.angle += Math.PI;\n      }\n\n      if (this.y === 0 || this.y === this.HEIGHT) {\n        this.vy = -this.vy;\n        this.angle += Math.PI;\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.x = this.WIDTH / 2;\n      this.y = this.HEIGHT / 2;\n      this.vx = 0;\n      this.vy = 0;\n      this.angle = Math.random() * Math.PI * 2;\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      window['p'].fill(0);\n      window['p'].ellipse(this.x, this.y, this.r * 2); // Score radius\n\n      window['p'].noFill();\n      window['p'].stroke('lightgreen');\n      window['p'].strokeWeight(2);\n      window['p'].ellipse(this.x, this.y, this.SCORE_RADIUS * 2);\n      window['p'].noStroke();\n    }\n  }]);\n\n  return Walker;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Walker);\n\n//# sourceURL=webpack:///./assets/js/classes/walker.jsx?");

/***/ }),

/***/ "./assets/js/constants/algorithms.js":
/*!*******************************************!*\
  !*** ./assets/js/constants/algorithms.js ***!
  \*******************************************/
/*! exports provided: NEAT, CNE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NEAT\", function() { return NEAT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CNE\", function() { return CNE; });\nvar NEAT = \"NEAT\";\nvar CNE = \"CNE\";\n\n//# sourceURL=webpack:///./assets/js/constants/algorithms.js?");

/***/ }),

/***/ "./assets/js/containers/App.jsx":
/*!**************************************!*\
  !*** ./assets/js/containers/App.jsx ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var HPO_containers_simulation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! HPO/containers/simulation */ \"./assets/js/containers/simulation.jsx\");\n/* harmony import */ var react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-bootstrap/Button */ \"./node_modules/react-bootstrap/Button.js\");\n/* harmony import */ var react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react_bootstrap_Container__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-bootstrap/Container */ \"./node_modules/react-bootstrap/Container.js\");\n/* harmony import */ var react_bootstrap_Container__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_bootstrap_Container__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var react_bootstrap_Row__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-bootstrap/Row */ \"./node_modules/react-bootstrap/Row.js\");\n/* harmony import */ var react_bootstrap_Row__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_bootstrap_Row__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var react_bootstrap_Col__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-bootstrap/Col */ \"./node_modules/react-bootstrap/Col.js\");\n/* harmony import */ var react_bootstrap_Col__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(react_bootstrap_Col__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var js_cookie__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! js-cookie */ \"./node_modules/js-cookie/src/js.cookie.js\");\n/* harmony import */ var js_cookie__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(js_cookie__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var HPO_constants_algorithms__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! HPO/constants/algorithms */ \"./assets/js/constants/algorithms.js\");\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n *\n * App\n *\n * This component is the skeleton around the actual page\n */\n\n\n\n\n\n\n\n\nvar WIDTH = 900;\nvar HEIGHT = 500;\n\nvar App =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(App, _React$Component);\n\n  function App(props) {\n    var _this;\n\n    _classCallCheck(this, App);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(App).call(this, props)); // This is the global variable where sample results will be stored\n\n    _defineProperty(_assertThisInitialized(_this), \"handleClick\", function () {\n      var currentState = _this.state.active;\n\n      _this.setState({\n        active: !currentState\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"algorithmChange\", function (event) {\n      _this.setState({\n        value: event.target.value\n      }); // Set the cookie and reload, the constructor handles the setting on load\n\n\n      js_cookie__WEBPACK_IMPORTED_MODULE_6___default.a.remove('algorithm');\n      js_cookie__WEBPACK_IMPORTED_MODULE_6___default.a.set('algorithm', event.target.value);\n      location.reload();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"save\", function () {\n      var results = window['results'];\n\n      if (results) {\n        var jsonString = encodeURIComponent(JSON.stringify(results));\n        var dataStr = \"data:text/json;charset=utf-8,\".concat(jsonString);\n\n        _this.setState({\n          dataStr: dataStr,\n          fileName: \"results.json\"\n        });\n      } else {\n        throw new Error(\"Result object is \".concat(_typeof(results)));\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"update\", function (e) {\n      var keys = e.detail;\n      Object.keys(keys).forEach(function (key) {\n        var val = keys[key];\n\n        _this.setState(_defineProperty({}, key, val));\n\n        if (key !== 'generation') {\n          window['results']['generations'][keys.generation][key] = val;\n        }\n      });\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"componentDidMount\", function () {\n      window.addEventListener(\"generationUpdate\", _this.update);\n    });\n\n    window['results'] = {\n      generations: {}\n    };\n    _this.state = {\n      active: true,\n      generation: null,\n      averageScore: null,\n      fittestScore: null,\n      maxGenerations: 100,\n      dataStr: null,\n      fileName: null,\n      value: js_cookie__WEBPACK_IMPORTED_MODULE_6___default.a.get('algorithm') === HPO_constants_algorithms__WEBPACK_IMPORTED_MODULE_7__[\"NEAT\"] ? HPO_constants_algorithms__WEBPACK_IMPORTED_MODULE_7__[\"NEAT\"] : HPO_constants_algorithms__WEBPACK_IMPORTED_MODULE_7__[\"CNE\"]\n    }; // Set the algorithm to whatever was last used\n\n    js_cookie__WEBPACK_IMPORTED_MODULE_6___default.a.set('algorithm', _this.state.value);\n    return _this;\n  }\n\n  _createClass(App, [{\n    key: \"render\",\n    value: function render() {\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_bootstrap_Container__WEBPACK_IMPORTED_MODULE_3___default.a, null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_bootstrap_Row__WEBPACK_IMPORTED_MODULE_4___default.a, null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_bootstrap_Col__WEBPACK_IMPORTED_MODULE_5___default.a, null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(HPO_containers_simulation__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n        active: this.state.active,\n        width: WIDTH,\n        height: HEIGHT,\n        algorithm: this.state.value,\n        maxGenerations: this.state.maxGenerations\n      }))), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_bootstrap_Row__WEBPACK_IMPORTED_MODULE_4___default.a, null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_bootstrap_Col__WEBPACK_IMPORTED_MODULE_5___default.a, null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"h4\", null, \"Generation: \", this.state.generation), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"h4\", null, \"Average Score: \", this.state.averageScore), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"h4\", null, \"Best Score: \", this.state.fittestScore), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"hr\", null)), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_bootstrap_Col__WEBPACK_IMPORTED_MODULE_5___default.a, null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"select\", {\n        onChange: this.algorithmChange,\n        value: this.state.value,\n        className: 'form-control'\n      }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"option\", {\n        value: HPO_constants_algorithms__WEBPACK_IMPORTED_MODULE_7__[\"NEAT\"]\n      }, \"NEAT with EA\"), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"option\", {\n        value: HPO_constants_algorithms__WEBPACK_IMPORTED_MODULE_7__[\"CNE\"]\n      }, \"NEAT with Random Search\")))), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_bootstrap_Row__WEBPACK_IMPORTED_MODULE_4___default.a, null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_bootstrap_Col__WEBPACK_IMPORTED_MODULE_5___default.a, null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_bootstrap_Button__WEBPACK_IMPORTED_MODULE_2___default.a, {\n        className: 'w-100 mb-3',\n        onClick: this.handleClick,\n        variant: \"primary\",\n        title: 'Pause the simulation'\n      }, this.state.active ? 'Pause' : 'Resume'), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"a\", {\n        className: 'btn btn-success d-block',\n        style: {\n          'cursor': 'pointer'\n        },\n        title: 'Save Results as a JSON file',\n        onClick: this.save,\n        href: this.state.dataStr,\n        download: this.state.fileName\n      }, \"Save as JSON\"))));\n    }\n  }]);\n\n  return App;\n}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);\n\nApp.defaultProps = {};\nApp.propTypes = {};\n/* harmony default export */ __webpack_exports__[\"default\"] = (App);\n\n//# sourceURL=webpack:///./assets/js/containers/App.jsx?");

/***/ }),

/***/ "./assets/js/containers/simulation.jsx":
/*!*********************************************!*\
  !*** ./assets/js/containers/simulation.jsx ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(__webpack_provided_window_dot_neat) {/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_p5_wrapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-p5-wrapper */ \"./node_modules/react-p5-wrapper/lib/P5Wrapper.js\");\n/* harmony import */ var react_p5_wrapper__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_p5_wrapper__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var HPO_sketches_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! HPO/sketches/index */ \"./assets/js/sketches/index.js\");\n/* harmony import */ var HPO_classes_player__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! HPO/classes/player */ \"./assets/js/classes/player.jsx\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var HPO_classes_walker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! HPO/classes/walker */ \"./assets/js/classes/walker.jsx\");\n/* harmony import */ var HPO_constants_algorithms__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! HPO/constants/algorithms */ \"./assets/js/constants/algorithms.js\");\n/* harmony import */ var js_cookie__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! js-cookie */ \"./node_modules/js-cookie/src/js.cookie.js\");\n/* harmony import */ var js_cookie__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(js_cookie__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var HPO_libs_neataptic_vanilla__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! HPO/libs/neataptic_vanilla */ \"./assets/js/libs/neataptic_vanilla/src/neataptic.js\");\n/* harmony import */ var HPO_libs_neataptic_vanilla__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(HPO_libs_neataptic_vanilla__WEBPACK_IMPORTED_MODULE_8__);\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n\n\n\n\n\n\n\n\n //import 'HPO/libs/neataptic_modified';\n//import 'neataptic';\n\nvar ALGORITHM = js_cookie__WEBPACK_IMPORTED_MODULE_7___default.a.get('algorithm');\nvar Neat = window['neataptic'].Neat;\nvar Methods = window['neataptic'].methods;\n/*if (ALGORITHM === NEAT) {\n\n    console.log(NEAT);\n    import('neataptic').then((module) => {\n\n        console.log(module);\n\n        Neat = module.Neat;\n        Methods = module.methods;\n    });\n\n} else {\n    console.log(CNE);\n    import('HPO/libs/neataptic_modified').then((module) => {\n\n        console.log(module);\n\n        Neat = module.Neat;\n        Methods = module.methods;\n\n    });\n\n}*/\n\nvar Simulation =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Simulation, _React$Component);\n\n  function Simulation(props) {\n    var _this;\n\n    _classCallCheck(this, Simulation);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Simulation).call(this, props));\n\n    _defineProperty(_assertThisInitialized(_this), \"initNeat\", function () {\n      window['walker'] = new HPO_classes_walker__WEBPACK_IMPORTED_MODULE_5__[\"default\"](_this.props.width / 2, _this.props.height / 2, _this.props.width, _this.props.height);\n      window['players'] = [];\n      window['generation'] = 0;\n      __webpack_provided_window_dot_neat = new Neat(6, // Input\n      1, // Output\n      null, // Fitness\n      {\n        // Options\n        popsize: _this.PLAYER_AMOUNT,\n        mutationRate: _this.MUTATION_RATE,\n        elitism: _this.ELITISM,\n        mutation: [Methods.mutation.ADD_NODE, Methods.mutation.SUB_NODE, Methods.mutation.ADD_CONN, Methods.mutation.SUB_CONN, Methods.mutation.MOD_WEIGHT, Methods.mutation.MOD_BIAS, Methods.mutation.MOD_ACTIVATION, Methods.mutation.ADD_GATE, Methods.mutation.SUB_GATE, Methods.mutation.ADD_SELF_CONN, Methods.mutation.SUB_SELF_CONN, Methods.mutation.ADD_BACK_CONN, Methods.mutation.SUB_BACK_CONN]\n      });\n\n      for (var i = 0; i <= _this.props.maxGenerations; i++) {\n        window['results'].generations[i] = {\n          mutationTimes: [],\n          crossoverTimes: []\n        };\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"startEvaluation\", function () {\n      window['players'] = [];\n      window['highestScore'] = 0;\n\n      for (var genome in __webpack_provided_window_dot_neat.population) {\n        genome = __webpack_provided_window_dot_neat.population[genome];\n        var newPlayer = new HPO_classes_player__WEBPACK_IMPORTED_MODULE_3__[\"default\"](genome, _this.props.width / 2, _this.props.height / 2, _this.props.width, _this.props.height);\n        window['players'].push(newPlayer);\n      }\n\n      window['walker'].reset();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"endEvaluation\", function () {\n      var event = new CustomEvent('generationUpdate', {\n        detail: {\n          generation: __webpack_provided_window_dot_neat.generation,\n          averageScore: Math.round(__webpack_provided_window_dot_neat.getAverage()),\n          fittestScore: Math.round(__webpack_provided_window_dot_neat.getFittest().score),\n          unfittestScore: Math.round(Math.min.apply(null, __webpack_provided_window_dot_neat.population.map(function (x) {\n            return x.score;\n          }))),\n          allScores: __webpack_provided_window_dot_neat.population.map(function (x) {\n            return x.score;\n          })\n        }\n      }); // Networks shouldn't get too big\n\n      for (var genome in __webpack_provided_window_dot_neat.population) {\n        genome = __webpack_provided_window_dot_neat.population[genome];\n        genome.score -= genome.nodes.length * _this.SCORE_RADIUS / 10;\n      } // Sort the population by score\n\n\n      __webpack_provided_window_dot_neat.sort(); // Init new pop\n\n      var newPopulation = [];\n      /**\n       * ELITISM\n       */\n\n      for (var i = 0; i < __webpack_provided_window_dot_neat.elitism; i++) {\n        newPopulation.push(__webpack_provided_window_dot_neat.population[i]);\n      }\n      /**\n       * SELECTION (?) && CROSSOVER\n       */\n\n\n      for (var _i = 0; _i < __webpack_provided_window_dot_neat.popsize - __webpack_provided_window_dot_neat.elitism; _i++) {\n        newPopulation.push(__webpack_provided_window_dot_neat.getOffspring());\n      } // Replace the old population with the new population\n\n\n      __webpack_provided_window_dot_neat.population = newPopulation;\n      /**\n       * MUTATION\n       */\n\n      __webpack_provided_window_dot_neat.mutate();\n      __webpack_provided_window_dot_neat.generation++;\n      window['generation']++;\n      window.dispatchEvent(event);\n\n      _this.startEvaluation();\n    });\n\n    _this.SCORE_RADIUS = 100;\n    _this.PLAYER_AMOUNT = 100; //Math.round(2.3e-4 * props.width * props.height);\n\n    _this.ITERATIONS = 250;\n    _this.MUTATION_RATE = 0.3;\n    _this.ELITISM = Math.round(0.1 * _this.PLAYER_AMOUNT);\n    _this.state = {\n      active: true,\n      stateSketch: HPO_sketches_index__WEBPACK_IMPORTED_MODULE_2__[\"default\"]\n    };\n    return _this;\n  }\n\n  _createClass(Simulation, [{\n    key: \"render\",\n    value: function render() {\n      return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react__WEBPACK_IMPORTED_MODULE_0___default.a.Fragment, null, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(react_p5_wrapper__WEBPACK_IMPORTED_MODULE_1___default.a, {\n        sketch: this.state.stateSketch,\n        status: this.props.active,\n        initNeat: this.initNeat,\n        startEvaluation: this.startEvaluation,\n        endEvaluation: this.endEvaluation.bind(this),\n        width: this.props.width,\n        height: this.props.height,\n        iterations: this.ITERATIONS,\n        maxGenerations: this.props.maxGenerations\n      }));\n    }\n  }]);\n\n  return Simulation;\n}(react__WEBPACK_IMPORTED_MODULE_0___default.a.Component);\n\nSimulation.defaultProps = {\n  active: true,\n  width: 900,\n  height: 500,\n  algorithm: HPO_constants_algorithms__WEBPACK_IMPORTED_MODULE_6__[\"NEAT\"],\n  maxGenerations: 100\n};\nSimulation.propTypes = {\n  active: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.bool,\n  width: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.number,\n  height: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.number,\n  algorithm: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.string,\n  maxGenerations: prop_types__WEBPACK_IMPORTED_MODULE_4___default.a.number\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Simulation);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! neataptic */ \"./node_modules/neataptic/src/neataptic.js\")))\n\n//# sourceURL=webpack:///./assets/js/containers/simulation.jsx?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/architecture/architect.js":
/*!************************************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/architecture/architect.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Import */\nvar methods = __webpack_require__(/*! ../methods/methods */ \"./assets/js/libs/neataptic_vanilla/src/methods/methods.js\");\n\nvar Network = __webpack_require__(/*! ./network */ \"./assets/js/libs/neataptic_vanilla/src/architecture/network.js\");\n\nvar Group = __webpack_require__(/*! ./group */ \"./assets/js/libs/neataptic_vanilla/src/architecture/group.js\");\n\nvar Layer = __webpack_require__(/*! ./layer */ \"./assets/js/libs/neataptic_vanilla/src/architecture/layer.js\");\n\nvar Node = __webpack_require__(/*! ./node */ \"./assets/js/libs/neataptic_vanilla/src/architecture/node.js\");\n/*******************************************************************************\r\n                                        architect\r\n*******************************************************************************/\n\n\nvar architect = {\n  /**\r\n   * Constructs a network from a given array of connected nodes\r\n   */\n  Construct: function Construct(list) {\n    // Create a network\n    var network = new Network(0, 0); // Transform all groups into nodes\n\n    var nodes = [];\n    var i;\n\n    for (i = 0; i < list.length; i++) {\n      var j = void 0;\n\n      if (list[i] instanceof Group) {\n        for (j = 0; j < list[i].nodes.length; j++) {\n          nodes.push(list[i].nodes[j]);\n        }\n      } else if (list[i] instanceof Layer) {\n        for (j = 0; j < list[i].nodes.length; j++) {\n          for (var k = 0; k < list[i].nodes[j].nodes.length; k++) {\n            nodes.push(list[i].nodes[j].nodes[k]);\n          }\n        }\n      } else if (list[i] instanceof Node) {\n        nodes.push(list[i]);\n      }\n    } // Determine input and output nodes\n\n\n    var inputs = [];\n    var outputs = [];\n\n    for (i = nodes.length - 1; i >= 0; i--) {\n      if (nodes[i].type === 'output' || nodes[i].connections.out.length + nodes[i].connections.gated.length === 0) {\n        nodes[i].type = 'output';\n        network.output++;\n        outputs.push(nodes[i]);\n        nodes.splice(i, 1);\n      } else if (nodes[i].type === 'input' || !nodes[i].connections[\"in\"].length) {\n        nodes[i].type = 'input';\n        network.input++;\n        inputs.push(nodes[i]);\n        nodes.splice(i, 1);\n      }\n    } // Input nodes are always first, output nodes are always last\n\n\n    nodes = inputs.concat(nodes).concat(outputs);\n\n    if (network.input === 0 || network.output === 0) {\n      throw new Error('Given nodes have no clear input/output node!');\n    }\n\n    for (i = 0; i < nodes.length; i++) {\n      var _j = void 0;\n\n      for (_j = 0; _j < nodes[i].connections.out.length; _j++) {\n        network.connections.push(nodes[i].connections.out[_j]);\n      }\n\n      for (_j = 0; _j < nodes[i].connections.gated.length; _j++) {\n        network.gates.push(nodes[i].connections.gated[_j]);\n      }\n\n      if (nodes[i].connections.self.weight !== 0) {\n        network.selfconns.push(nodes[i].connections.self);\n      }\n    }\n\n    network.nodes = nodes;\n    return network;\n  },\n\n  /**\r\n   * Creates a multilayer perceptron (MLP)\r\n   */\n  Perceptron: function Perceptron() {\n    // Convert arguments to Array\n    var layers = Array.prototype.slice.call(arguments);\n\n    if (layers.length < 3) {\n      throw new Error('You have to specify at least 3 layers');\n    } // Create a list of nodes/groups\n\n\n    var nodes = [];\n    nodes.push(new Group(layers[0]));\n\n    for (var i = 1; i < layers.length; i++) {\n      var layer = layers[i];\n      layer = new Group(layer);\n      nodes.push(layer);\n      nodes[i - 1].connect(nodes[i], methods.connection.ALL_TO_ALL);\n    } // Construct the network\n\n\n    return architect.Construct(nodes);\n  },\n\n  /**\r\n   * Creates a randomly connected network\r\n   */\n  Random: function Random(input, hidden, output, options) {\n    options = options || {};\n    var connections = options.connections || hidden * 2;\n    var backconnections = options.backconnections || 0;\n    var selfconnections = options.selfconnections || 0;\n    var gates = options.gates || 0;\n    var network = new Network(input, output);\n    var i;\n\n    for (i = 0; i < hidden; i++) {\n      network.mutate(methods.mutation.ADD_NODE);\n    }\n\n    for (i = 0; i < connections - hidden; i++) {\n      network.mutate(methods.mutation.ADD_CONN);\n    }\n\n    for (i = 0; i < backconnections; i++) {\n      network.mutate(methods.mutation.ADD_BACK_CONN);\n    }\n\n    for (i = 0; i < selfconnections; i++) {\n      network.mutate(methods.mutation.ADD_SELF_CONN);\n    }\n\n    for (i = 0; i < gates; i++) {\n      network.mutate(methods.mutation.ADD_GATE);\n    }\n\n    return network;\n  },\n\n  /**\r\n   * Creates a long short-term memory network\r\n   */\n  LSTM: function LSTM() {\n    var args = Array.prototype.slice.call(arguments);\n\n    if (args.length < 3) {\n      throw new Error('You have to specify at least 3 layers');\n    }\n\n    var last = args.pop();\n    var outputLayer;\n\n    if (typeof last === 'number') {\n      outputLayer = new Group(last);\n      last = {};\n    } else {\n      outputLayer = new Group(args.pop()); // last argument\n    }\n\n    outputLayer.set({\n      type: 'output'\n    });\n    var options = {};\n    options.memoryToMemory = last.memoryToMemory || false;\n    options.outputToMemory = last.outputToMemory || false;\n    options.outputToGates = last.outputToGates || false;\n    options.inputToOutput = last.inputToOutput === undefined ? true : last.inputToOutput;\n    options.inputToDeep = last.inputToDeep === undefined ? true : last.inputToDeep;\n    var inputLayer = new Group(args.shift()); // first argument\n\n    inputLayer.set({\n      type: 'input'\n    });\n    var blocks = args; // all the arguments in the middle\n\n    var nodes = [];\n    nodes.push(inputLayer);\n    var previous = inputLayer;\n\n    for (var i = 0; i < blocks.length; i++) {\n      var block = blocks[i]; // Init required nodes (in activation order)\n\n      var inputGate = new Group(block);\n      var forgetGate = new Group(block);\n      var memoryCell = new Group(block);\n      var outputGate = new Group(block);\n      var outputBlock = i === blocks.length - 1 ? outputLayer : new Group(block);\n      inputGate.set({\n        bias: 1\n      });\n      forgetGate.set({\n        bias: 1\n      });\n      outputGate.set({\n        bias: 1\n      }); // Connect the input with all the nodes\n\n      var input = previous.connect(memoryCell, methods.connection.ALL_TO_ALL);\n      previous.connect(inputGate, methods.connection.ALL_TO_ALL);\n      previous.connect(outputGate, methods.connection.ALL_TO_ALL);\n      previous.connect(forgetGate, methods.connection.ALL_TO_ALL); // Set up internal connections\n\n      memoryCell.connect(inputGate, methods.connection.ALL_TO_ALL);\n      memoryCell.connect(forgetGate, methods.connection.ALL_TO_ALL);\n      memoryCell.connect(outputGate, methods.connection.ALL_TO_ALL);\n      var forget = memoryCell.connect(memoryCell, methods.connection.ONE_TO_ONE);\n      var output = memoryCell.connect(outputBlock, methods.connection.ALL_TO_ALL); // Set up gates\n\n      inputGate.gate(input, methods.gating.INPUT);\n      forgetGate.gate(forget, methods.gating.SELF);\n      outputGate.gate(output, methods.gating.OUTPUT); // Input to all memory cells\n\n      if (options.inputToDeep && i > 0) {\n        var _input = inputLayer.connect(memoryCell, methods.connection.ALL_TO_ALL);\n\n        inputGate.gate(_input, methods.gating.INPUT);\n      } // Optional connections\n\n\n      if (options.memoryToMemory) {\n        var _input2 = memoryCell.connect(memoryCell, methods.connection.ALL_TO_ELSE);\n\n        inputGate.gate(_input2, methods.gating.INPUT);\n      }\n\n      if (options.outputToMemory) {\n        var _input3 = outputLayer.connect(memoryCell, methods.connection.ALL_TO_ALL);\n\n        inputGate.gate(_input3, methods.gating.INPUT);\n      }\n\n      if (options.outputToGates) {\n        outputLayer.connect(inputGate, methods.connection.ALL_TO_ALL);\n        outputLayer.connect(forgetGate, methods.connection.ALL_TO_ALL);\n        outputLayer.connect(outputGate, methods.connection.ALL_TO_ALL);\n      } // Add to array\n\n\n      nodes.push(inputGate);\n      nodes.push(forgetGate);\n      nodes.push(memoryCell);\n      nodes.push(outputGate);\n      if (i !== blocks.length - 1) nodes.push(outputBlock);\n      previous = outputBlock;\n    } // input to output direct connection\n\n\n    if (options.inputToOutput) {\n      inputLayer.connect(outputLayer, methods.connection.ALL_TO_ALL);\n    }\n\n    nodes.push(outputLayer);\n    return architect.Construct(nodes);\n  },\n\n  /**\r\n   * Creates a gated recurrent unit network\r\n   */\n  GRU: function GRU() {\n    var args = Array.prototype.slice.call(arguments);\n\n    if (args.length < 3) {\n      throw new Error('not enough layers (minimum 3) !!');\n    }\n\n    var inputLayer = new Group(args.shift()); // first argument\n\n    var outputLayer = new Group(args.pop()); // last argument\n\n    var blocks = args; // all the arguments in the middle\n\n    var nodes = [];\n    nodes.push(inputLayer);\n    var previous = inputLayer;\n\n    for (var i = 0; i < blocks.length; i++) {\n      var layer = new Layer.GRU(blocks[i]);\n      previous.connect(layer);\n      previous = layer;\n      nodes.push(layer);\n    }\n\n    previous.connect(outputLayer);\n    nodes.push(outputLayer);\n    return architect.Construct(nodes);\n  },\n\n  /**\r\n   * Creates a hopfield network of the given size\r\n   */\n  Hopfield: function Hopfield(size) {\n    var input = new Group(size);\n    var output = new Group(size);\n    input.connect(output, methods.connection.ALL_TO_ALL);\n    input.set({\n      type: 'input'\n    });\n    output.set({\n      squash: methods.activation.STEP,\n      type: 'output'\n    });\n    var network = new architect.Construct([input, output]);\n    return network;\n  },\n\n  /**\r\n   * Creates a NARX network (remember previous inputs/outputs)\r\n   */\n  NARX: function NARX(inputSize, hiddenLayers, outputSize, previousInput, previousOutput) {\n    if (!Array.isArray(hiddenLayers)) {\n      hiddenLayers = [hiddenLayers];\n    }\n\n    var nodes = [];\n    var input = new Layer.Dense(inputSize);\n    var inputMemory = new Layer.Memory(inputSize, previousInput);\n    var hidden = [];\n    var output = new Layer.Dense(outputSize);\n    var outputMemory = new Layer.Memory(outputSize, previousOutput);\n    nodes.push(input);\n    nodes.push(outputMemory);\n\n    for (var i = 0; i < hiddenLayers.length; i++) {\n      var hiddenLayer = new Layer.Dense(hiddenLayers[i]);\n      hidden.push(hiddenLayer);\n      nodes.push(hiddenLayer);\n\n      if (typeof hidden[i - 1] !== 'undefined') {\n        hidden[i - 1].connect(hiddenLayer, methods.connection.ALL_TO_ALL);\n      }\n    }\n\n    nodes.push(inputMemory);\n    nodes.push(output);\n    input.connect(hidden[0], methods.connection.ALL_TO_ALL);\n    input.connect(inputMemory, methods.connection.ONE_TO_ONE, 1);\n    inputMemory.connect(hidden[0], methods.connection.ALL_TO_ALL);\n    hidden[hidden.length - 1].connect(output, methods.connection.ALL_TO_ALL);\n    output.connect(outputMemory, methods.connection.ONE_TO_ONE, 1);\n    outputMemory.connect(hidden[0], methods.connection.ALL_TO_ALL);\n    input.set({\n      type: 'input'\n    });\n    output.set({\n      type: 'output'\n    });\n    return architect.Construct(nodes);\n  }\n};\n/* Export */\n\nmodule.exports = architect;\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/architecture/architect.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/architecture/connection.js":
/*!*************************************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/architecture/connection.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* Export */\nmodule.exports = Connection;\n/*******************************************************************************\r\n                                      CONNECTION\r\n*******************************************************************************/\n\nfunction Connection(from, to, weight) {\n  this.from = from;\n  this.to = to;\n  this.gain = 1;\n  this.weight = typeof weight === 'undefined' ? Math.random() * 0.2 - 0.1 : weight;\n  this.gater = null;\n  this.elegibility = 0; // For tracking momentum\n\n  this.previousDeltaWeight = 0; // Batch training\n\n  this.totalDeltaWeight = 0;\n  this.xtrace = {\n    nodes: [],\n    values: []\n  };\n}\n\nConnection.prototype = {\n  /**\r\n   * Converts the connection to a json object\r\n   */\n  toJSON: function toJSON() {\n    var json = {\n      weight: this.weight\n    };\n    return json;\n  }\n};\n/**\r\n * Returns an innovation ID\r\n * https://en.wikipedia.org/wiki/Pairing_function (Cantor pairing function)\r\n */\n\nConnection.innovationID = function (a, b) {\n  return 1 / 2 * (a + b) * (a + b + 1) + b;\n};\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/architecture/connection.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/architecture/group.js":
/*!********************************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/architecture/group.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Export */\nmodule.exports = Group;\n/* Import */\n\nvar methods = __webpack_require__(/*! ../methods/methods */ \"./assets/js/libs/neataptic_vanilla/src/methods/methods.js\");\n\nvar config = __webpack_require__(/*! ../config */ \"./assets/js/libs/neataptic_vanilla/src/config.js\");\n\nvar Layer = __webpack_require__(/*! ./layer */ \"./assets/js/libs/neataptic_vanilla/src/architecture/layer.js\");\n\nvar Node = __webpack_require__(/*! ./node */ \"./assets/js/libs/neataptic_vanilla/src/architecture/node.js\");\n/*******************************************************************************\r\n                                         Group\r\n*******************************************************************************/\n\n\nfunction Group(size) {\n  this.nodes = [];\n  this.connections = {\n    \"in\": [],\n    out: [],\n    self: []\n  };\n\n  for (var i = 0; i < size; i++) {\n    this.nodes.push(new Node());\n  }\n}\n\nGroup.prototype = {\n  /**\r\n   * Activates all the nodes in the group\r\n   */\n  activate: function activate(value) {\n    var values = [];\n\n    if (typeof value !== 'undefined' && value.length !== this.nodes.length) {\n      throw new Error('Array with values should be same as the amount of nodes!');\n    }\n\n    for (var i = 0; i < this.nodes.length; i++) {\n      var activation;\n\n      if (typeof value === 'undefined') {\n        activation = this.nodes[i].activate();\n      } else {\n        activation = this.nodes[i].activate(value[i]);\n      }\n\n      values.push(activation);\n    }\n\n    return values;\n  },\n\n  /**\r\n   * Propagates all the node in the group\r\n   */\n  propagate: function propagate(rate, momentum, target) {\n    if (typeof target !== 'undefined' && target.length !== this.nodes.length) {\n      throw new Error('Array with values should be same as the amount of nodes!');\n    }\n\n    for (var i = this.nodes.length - 1; i >= 0; i--) {\n      if (typeof target === 'undefined') {\n        this.nodes[i].propagate(rate, momentum, true);\n      } else {\n        this.nodes[i].propagate(rate, momentum, true, target[i]);\n      }\n    }\n  },\n\n  /**\r\n   * Connects the nodes in this group to nodes in another group or just a node\r\n   */\n  connect: function connect(target, method, weight) {\n    var connections = [];\n    var i, j;\n\n    if (target instanceof Group) {\n      if (typeof method === 'undefined') {\n        if (this !== target) {\n          if (config.warnings) console.warn('No group connection specified, using ALL_TO_ALL');\n          method = methods.connection.ALL_TO_ALL;\n        } else {\n          if (config.warnings) console.warn('No group connection specified, using ONE_TO_ONE');\n          method = methods.connection.ONE_TO_ONE;\n        }\n      }\n\n      if (method === methods.connection.ALL_TO_ALL || method === methods.connection.ALL_TO_ELSE) {\n        for (i = 0; i < this.nodes.length; i++) {\n          for (j = 0; j < target.nodes.length; j++) {\n            if (method === methods.connection.ALL_TO_ELSE && this.nodes[i] === target.nodes[j]) continue;\n            var connection = this.nodes[i].connect(target.nodes[j], weight);\n            this.connections.out.push(connection[0]);\n            target.connections[\"in\"].push(connection[0]);\n            connections.push(connection[0]);\n          }\n        }\n      } else if (method === methods.connection.ONE_TO_ONE) {\n        if (this.nodes.length !== target.nodes.length) {\n          throw new Error('From and To group must be the same size!');\n        }\n\n        for (i = 0; i < this.nodes.length; i++) {\n          var _connection = this.nodes[i].connect(target.nodes[i], weight);\n\n          this.connections.self.push(_connection[0]);\n          connections.push(_connection[0]);\n        }\n      }\n    } else if (target instanceof Layer) {\n      connections = target.input(this, method, weight);\n    } else if (target instanceof Node) {\n      for (i = 0; i < this.nodes.length; i++) {\n        var _connection2 = this.nodes[i].connect(target, weight);\n\n        this.connections.out.push(_connection2[0]);\n        connections.push(_connection2[0]);\n      }\n    }\n\n    return connections;\n  },\n\n  /**\r\n   * Make nodes from this group gate the given connection(s)\r\n   */\n  gate: function gate(connections, method) {\n    if (typeof method === 'undefined') {\n      throw new Error('Please specify Gating.INPUT, Gating.OUTPUT');\n    }\n\n    if (!Array.isArray(connections)) {\n      connections = [connections];\n    }\n\n    var nodes1 = [];\n    var nodes2 = [];\n    var i, j;\n\n    for (i = 0; i < connections.length; i++) {\n      var connection = connections[i];\n      if (!nodes1.includes(connection.from)) nodes1.push(connection.from);\n      if (!nodes2.includes(connection.to)) nodes2.push(connection.to);\n    }\n\n    switch (method) {\n      case methods.gating.INPUT:\n        for (i = 0; i < nodes2.length; i++) {\n          var node = nodes2[i];\n          var gater = this.nodes[i % this.nodes.length];\n\n          for (j = 0; j < node.connections[\"in\"].length; j++) {\n            var conn = node.connections[\"in\"][j];\n\n            if (connections.includes(conn)) {\n              gater.gate(conn);\n            }\n          }\n        }\n\n        break;\n\n      case methods.gating.OUTPUT:\n        for (i = 0; i < nodes1.length; i++) {\n          var _node = nodes1[i];\n          var _gater = this.nodes[i % this.nodes.length];\n\n          for (j = 0; j < _node.connections.out.length; j++) {\n            var _conn = _node.connections.out[j];\n\n            if (connections.includes(_conn)) {\n              _gater.gate(_conn);\n            }\n          }\n        }\n\n        break;\n\n      case methods.gating.SELF:\n        for (i = 0; i < nodes1.length; i++) {\n          var _node2 = nodes1[i];\n          var _gater2 = this.nodes[i % this.nodes.length];\n\n          if (connections.includes(_node2.connections.self)) {\n            _gater2.gate(_node2.connections.self);\n          }\n        }\n\n    }\n  },\n\n  /**\r\n   * Sets the value of a property for every node\r\n   */\n  set: function set(values) {\n    for (var i = 0; i < this.nodes.length; i++) {\n      if (typeof values.bias !== 'undefined') {\n        this.nodes[i].bias = values.bias;\n      }\n\n      this.nodes[i].squash = values.squash || this.nodes[i].squash;\n      this.nodes[i].type = values.type || this.nodes[i].type;\n    }\n  },\n\n  /**\r\n   * Disconnects all nodes from this group from another given group/node\r\n   */\n  disconnect: function disconnect(target, twosided) {\n    twosided = twosided || false; // In the future, disconnect will return a connection so indexOf can be used\n\n    var i, j, k;\n\n    if (target instanceof Group) {\n      for (i = 0; i < this.nodes.length; i++) {\n        for (j = 0; j < target.nodes.length; j++) {\n          this.nodes[i].disconnect(target.nodes[j], twosided);\n\n          for (k = this.connections.out.length - 1; k >= 0; k--) {\n            var _conn2 = this.connections.out[k];\n\n            if (_conn2.from === this.nodes[i] && _conn2.to === target.nodes[j]) {\n              this.connections.out.splice(k, 1);\n              break;\n            }\n          }\n\n          if (twosided) {\n            for (k = this.connections[\"in\"].length - 1; k >= 0; k--) {\n              var _conn3 = this.connections[\"in\"][k];\n\n              if (_conn3.from === target.nodes[j] && _conn3.to === this.nodes[i]) {\n                this.connections[\"in\"].splice(k, 1);\n                break;\n              }\n            }\n          }\n        }\n      }\n    } else if (target instanceof Node) {\n      for (i = 0; i < this.nodes.length; i++) {\n        this.nodes[i].disconnect(target, twosided);\n\n        for (j = this.connections.out.length - 1; j >= 0; j--) {\n          var _conn4 = this.connections.out[j];\n\n          if (_conn4.from === this.nodes[i] && _conn4.to === target) {\n            this.connections.out.splice(j, 1);\n            break;\n          }\n        }\n\n        if (twosided) {\n          for (j = this.connections[\"in\"].length - 1; j >= 0; j--) {\n            var conn = this.connections[\"in\"][j];\n\n            if (conn.from === target && conn.to === this.nodes[i]) {\n              this.connections[\"in\"].splice(j, 1);\n              break;\n            }\n          }\n        }\n      }\n    }\n  },\n\n  /**\r\n   * Clear the context of this group\r\n   */\n  clear: function clear() {\n    for (var i = 0; i < this.nodes.length; i++) {\n      this.nodes[i].clear();\n    }\n  }\n};\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/architecture/group.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/architecture/layer.js":
/*!********************************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/architecture/layer.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Export */\nmodule.exports = Layer;\n/* Import */\n\nvar methods = __webpack_require__(/*! ../methods/methods */ \"./assets/js/libs/neataptic_vanilla/src/methods/methods.js\");\n\nvar Group = __webpack_require__(/*! ./group */ \"./assets/js/libs/neataptic_vanilla/src/architecture/group.js\");\n\nvar Node = __webpack_require__(/*! ./node */ \"./assets/js/libs/neataptic_vanilla/src/architecture/node.js\");\n/*******************************************************************************\r\n                                         Group\r\n*******************************************************************************/\n\n\nfunction Layer() {\n  this.output = null;\n  this.nodes = [];\n  this.connections = {\n    \"in\": [],\n    out: [],\n    self: []\n  };\n}\n\nLayer.prototype = {\n  /**\r\n   * Activates all the nodes in the group\r\n   */\n  activate: function activate(value) {\n    var values = [];\n\n    if (typeof value !== 'undefined' && value.length !== this.nodes.length) {\n      throw new Error('Array with values should be same as the amount of nodes!');\n    }\n\n    for (var i = 0; i < this.nodes.length; i++) {\n      var activation;\n\n      if (typeof value === 'undefined') {\n        activation = this.nodes[i].activate();\n      } else {\n        activation = this.nodes[i].activate(value[i]);\n      }\n\n      values.push(activation);\n    }\n\n    return values;\n  },\n\n  /**\r\n   * Propagates all the node in the group\r\n   */\n  propagate: function propagate(rate, momentum, target) {\n    if (typeof target !== 'undefined' && target.length !== this.nodes.length) {\n      throw new Error('Array with values should be same as the amount of nodes!');\n    }\n\n    for (var i = this.nodes.length - 1; i >= 0; i--) {\n      if (typeof target === 'undefined') {\n        this.nodes[i].propagate(rate, momentum, true);\n      } else {\n        this.nodes[i].propagate(rate, momentum, true, target[i]);\n      }\n    }\n  },\n\n  /**\r\n   * Connects the nodes in this group to nodes in another group or just a node\r\n   */\n  connect: function connect(target, method, weight) {\n    var connections;\n\n    if (target instanceof Group || target instanceof Node) {\n      connections = this.output.connect(target, method, weight);\n    } else if (target instanceof Layer) {\n      connections = target.input(this, method, weight);\n    }\n\n    return connections;\n  },\n\n  /**\r\n   * Make nodes from this group gate the given connection(s)\r\n   */\n  gate: function gate(connections, method) {\n    this.output.gate(connections, method);\n  },\n\n  /**\r\n   * Sets the value of a property for every node\r\n   */\n  set: function set(values) {\n    for (var i = 0; i < this.nodes.length; i++) {\n      var node = this.nodes[i];\n\n      if (node instanceof Node) {\n        if (typeof values.bias !== 'undefined') {\n          node.bias = values.bias;\n        }\n\n        node.squash = values.squash || node.squash;\n        node.type = values.type || node.type;\n      } else if (node instanceof Group) {\n        node.set(values);\n      }\n    }\n  },\n\n  /**\r\n   * Disconnects all nodes from this group from another given group/node\r\n   */\n  disconnect: function disconnect(target, twosided) {\n    twosided = twosided || false; // In the future, disconnect will return a connection so indexOf can be used\n\n    var i, j, k;\n\n    if (target instanceof Group) {\n      for (i = 0; i < this.nodes.length; i++) {\n        for (j = 0; j < target.nodes.length; j++) {\n          this.nodes[i].disconnect(target.nodes[j], twosided);\n\n          for (k = this.connections.out.length - 1; k >= 0; k--) {\n            var conn = this.connections.out[k];\n\n            if (conn.from === this.nodes[i] && conn.to === target.nodes[j]) {\n              this.connections.out.splice(k, 1);\n              break;\n            }\n          }\n\n          if (twosided) {\n            for (k = this.connections[\"in\"].length - 1; k >= 0; k--) {\n              var _conn = this.connections[\"in\"][k];\n\n              if (_conn.from === target.nodes[j] && _conn.to === this.nodes[i]) {\n                this.connections[\"in\"].splice(k, 1);\n                break;\n              }\n            }\n          }\n        }\n      }\n    } else if (target instanceof Node) {\n      for (i = 0; i < this.nodes.length; i++) {\n        this.nodes[i].disconnect(target, twosided);\n\n        for (j = this.connections.out.length - 1; j >= 0; j--) {\n          var _conn2 = this.connections.out[j];\n\n          if (_conn2.from === this.nodes[i] && _conn2.to === target) {\n            this.connections.out.splice(j, 1);\n            break;\n          }\n        }\n\n        if (twosided) {\n          for (k = this.connections[\"in\"].length - 1; k >= 0; k--) {\n            var _conn3 = this.connections[\"in\"][k];\n\n            if (_conn3.from === target && _conn3.to === this.nodes[i]) {\n              this.connections[\"in\"].splice(k, 1);\n              break;\n            }\n          }\n        }\n      }\n    }\n  },\n\n  /**\r\n   * Clear the context of this group\r\n   */\n  clear: function clear() {\n    for (var i = 0; i < this.nodes.length; i++) {\n      this.nodes[i].clear();\n    }\n  }\n};\n\nLayer.Dense = function (size) {\n  // Create the layer\n  var layer = new Layer(); // Init required nodes (in activation order)\n\n  var block = new Group(size);\n  layer.nodes.push(block);\n  layer.output = block;\n\n  layer.input = function (from, method, weight) {\n    if (from instanceof Layer) from = from.output;\n    method = method || methods.connection.ALL_TO_ALL;\n    return from.connect(block, method, weight);\n  };\n\n  return layer;\n};\n\nLayer.LSTM = function (size) {\n  // Create the layer\n  var layer = new Layer(); // Init required nodes (in activation order)\n\n  var inputGate = new Group(size);\n  var forgetGate = new Group(size);\n  var memoryCell = new Group(size);\n  var outputGate = new Group(size);\n  var outputBlock = new Group(size);\n  inputGate.set({\n    bias: 1\n  });\n  forgetGate.set({\n    bias: 1\n  });\n  outputGate.set({\n    bias: 1\n  }); // Set up internal connections\n\n  memoryCell.connect(inputGate, methods.connection.ALL_TO_ALL);\n  memoryCell.connect(forgetGate, methods.connection.ALL_TO_ALL);\n  memoryCell.connect(outputGate, methods.connection.ALL_TO_ALL);\n  var forget = memoryCell.connect(memoryCell, methods.connection.ONE_TO_ONE);\n  var output = memoryCell.connect(outputBlock, methods.connection.ALL_TO_ALL); // Set up gates\n\n  forgetGate.gate(forget, methods.gating.SELF);\n  outputGate.gate(output, methods.gating.OUTPUT); // Add to nodes array\n\n  layer.nodes = [inputGate, forgetGate, memoryCell, outputGate, outputBlock]; // Define output\n\n  layer.output = outputBlock;\n\n  layer.input = function (from, method, weight) {\n    if (from instanceof Layer) from = from.output;\n    method = method || methods.connection.ALL_TO_ALL;\n    var connections = [];\n    var input = from.connect(memoryCell, method, weight);\n    connections = connections.concat(input);\n    connections = connections.concat(from.connect(inputGate, method, weight));\n    connections = connections.concat(from.connect(outputGate, method, weight));\n    connections = connections.concat(from.connect(forgetGate, method, weight));\n    inputGate.gate(input, methods.gating.INPUT);\n    return connections;\n  };\n\n  return layer;\n};\n\nLayer.GRU = function (size) {\n  // Create the layer\n  var layer = new Layer();\n  var updateGate = new Group(size);\n  var inverseUpdateGate = new Group(size);\n  var resetGate = new Group(size);\n  var memoryCell = new Group(size);\n  var output = new Group(size);\n  var previousOutput = new Group(size);\n  previousOutput.set({\n    bias: 0,\n    squash: methods.activation.IDENTITY,\n    type: 'constant'\n  });\n  memoryCell.set({\n    squash: methods.activation.TANH\n  });\n  inverseUpdateGate.set({\n    bias: 0,\n    squash: methods.activation.INVERSE,\n    type: 'constant'\n  });\n  updateGate.set({\n    bias: 1\n  });\n  resetGate.set({\n    bias: 0\n  }); // Update gate calculation\n\n  previousOutput.connect(updateGate, methods.connection.ALL_TO_ALL); // Inverse update gate calculation\n\n  updateGate.connect(inverseUpdateGate, methods.connection.ONE_TO_ONE, 1); // Reset gate calculation\n\n  previousOutput.connect(resetGate, methods.connection.ALL_TO_ALL); // Memory calculation\n\n  var reset = previousOutput.connect(memoryCell, methods.connection.ALL_TO_ALL);\n  resetGate.gate(reset, methods.gating.OUTPUT); // gate\n  // Output calculation\n\n  var update1 = previousOutput.connect(output, methods.connection.ALL_TO_ALL);\n  var update2 = memoryCell.connect(output, methods.connection.ALL_TO_ALL);\n  updateGate.gate(update1, methods.gating.OUTPUT);\n  inverseUpdateGate.gate(update2, methods.gating.OUTPUT); // Previous output calculation\n\n  output.connect(previousOutput, methods.connection.ONE_TO_ONE, 1); // Add to nodes array\n\n  layer.nodes = [updateGate, inverseUpdateGate, resetGate, memoryCell, output, previousOutput];\n  layer.output = output;\n\n  layer.input = function (from, method, weight) {\n    if (from instanceof Layer) from = from.output;\n    method = method || methods.connection.ALL_TO_ALL;\n    var connections = [];\n    connections = connections.concat(from.connect(updateGate, method, weight));\n    connections = connections.concat(from.connect(resetGate, method, weight));\n    connections = connections.concat(from.connect(memoryCell, method, weight));\n    return connections;\n  };\n\n  return layer;\n};\n\nLayer.Memory = function (size, memory) {\n  // Create the layer\n  var layer = new Layer(); // Because the output can only be one group, we have to put the nodes all in ne group\n\n  var previous = null;\n  var i;\n\n  for (i = 0; i < memory; i++) {\n    var block = new Group(size);\n    block.set({\n      squash: methods.activation.IDENTITY,\n      bias: 0,\n      type: 'constant'\n    });\n\n    if (previous != null) {\n      previous.connect(block, methods.connection.ONE_TO_ONE, 1);\n    }\n\n    layer.nodes.push(block);\n    previous = block;\n  }\n\n  layer.nodes.reverse();\n\n  for (i = 0; i < layer.nodes.length; i++) {\n    layer.nodes[i].nodes.reverse();\n  } // Because output can only be ne group, fit all memory nodes in ne group\n\n\n  var outputGroup = new Group(0);\n\n  for (var group in layer.nodes) {\n    outputGroup.nodes = outputGroup.nodes.concat(layer.nodes[group].nodes);\n  }\n\n  layer.output = outputGroup;\n\n  layer.input = function (from, method, weight) {\n    if (from instanceof Layer) from = from.output;\n    method = method || methods.connection.ALL_TO_ALL;\n\n    if (from.nodes.length !== layer.nodes[layer.nodes.length - 1].nodes.length) {\n      throw new Error('Previous layer size must be same as memory size');\n    }\n\n    return from.connect(layer.nodes[layer.nodes.length - 1], methods.connection.ONE_TO_ONE, 1);\n  };\n\n  return layer;\n};\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/architecture/layer.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/architecture/network.js":
/*!**********************************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/architecture/network.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n/* Export */\nmodule.exports = Network;\n/* Import */\n\nvar multi = __webpack_require__(/*! ../multithreading/multi */ \"./assets/js/libs/neataptic_vanilla/src/multithreading/multi.js\");\n\nvar methods = __webpack_require__(/*! ../methods/methods */ \"./assets/js/libs/neataptic_vanilla/src/methods/methods.js\");\n\nvar Connection = __webpack_require__(/*! ./connection */ \"./assets/js/libs/neataptic_vanilla/src/architecture/connection.js\");\n\nvar config = __webpack_require__(/*! ../config */ \"./assets/js/libs/neataptic_vanilla/src/config.js\");\n\nvar Neat = __webpack_require__(/*! ../neat */ \"./assets/js/libs/neataptic_vanilla/src/neat.js\");\n\nvar Node = __webpack_require__(/*! ./node */ \"./assets/js/libs/neataptic_vanilla/src/architecture/node.js\");\n/* Easier variable naming */\n\n\nvar mutation = methods.mutation;\n/*******************************************************************************\r\n                                 NETWORK\r\n*******************************************************************************/\n\nfunction Network(input, output) {\n  if (typeof input === 'undefined' || typeof output === 'undefined') {\n    throw new Error('No input or output size given');\n  }\n\n  this.input = input;\n  this.output = output; // Store all the node and connection genes\n\n  this.nodes = []; // Stored in activation order\n\n  this.connections = [];\n  this.gates = [];\n  this.selfconns = []; // Regularization\n\n  this.dropout = 0; // Create input and output nodes\n\n  var i;\n\n  for (i = 0; i < this.input + this.output; i++) {\n    var type = i < this.input ? 'input' : 'output';\n    this.nodes.push(new Node(type));\n  } // Connect input nodes with output nodes directly\n\n\n  for (i = 0; i < this.input; i++) {\n    for (var j = this.input; j < this.output + this.input; j++) {\n      // https://stats.stackexchange.com/a/248040/147931\n      var weight = Math.random() * this.input * Math.sqrt(2 / this.input);\n      this.connect(this.nodes[i], this.nodes[j], weight);\n    }\n  }\n}\n\nNetwork.prototype = {\n  /**\r\n   * Activates the network\r\n   */\n  activate: function activate(input, training) {\n    var output = []; // Activate nodes chronologically\n\n    for (var i = 0; i < this.nodes.length; i++) {\n      if (this.nodes[i].type === 'input') {\n        this.nodes[i].activate(input[i]);\n      } else if (this.nodes[i].type === 'output') {\n        var activation = this.nodes[i].activate();\n        output.push(activation);\n      } else {\n        if (training) this.nodes[i].mask = Math.random() < this.dropout ? 0 : 1;\n        this.nodes[i].activate();\n      }\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Activates the network without calculating elegibility traces and such\r\n   */\n  noTraceActivate: function noTraceActivate(input) {\n    var output = []; // Activate nodes chronologically\n\n    for (var i = 0; i < this.nodes.length; i++) {\n      if (this.nodes[i].type === 'input') {\n        this.nodes[i].noTraceActivate(input[i]);\n      } else if (this.nodes[i].type === 'output') {\n        var activation = this.nodes[i].noTraceActivate();\n        output.push(activation);\n      } else {\n        this.nodes[i].noTraceActivate();\n      }\n    }\n\n    return output;\n  },\n\n  /**\r\n   * Backpropagate the network\r\n   */\n  propagate: function propagate(rate, momentum, update, target) {\n    if (typeof target === 'undefined' || target.length !== this.output) {\n      throw new Error('Output target length should match network output length');\n    }\n\n    var targetIndex = target.length; // Propagate output nodes\n\n    var i;\n\n    for (i = this.nodes.length - 1; i >= this.nodes.length - this.output; i--) {\n      this.nodes[i].propagate(rate, momentum, update, target[--targetIndex]);\n    } // Propagate hidden and input nodes\n\n\n    for (i = this.nodes.length - this.output - 1; i >= this.input; i--) {\n      this.nodes[i].propagate(rate, momentum, update);\n    }\n  },\n\n  /**\r\n   * Clear the context of the network\r\n   */\n  clear: function clear() {\n    for (var i = 0; i < this.nodes.length; i++) {\n      this.nodes[i].clear();\n    }\n  },\n\n  /**\r\n   * Connects the from node to the to node\r\n   */\n  connect: function connect(from, to, weight) {\n    var connections = from.connect(to, weight);\n\n    for (var i = 0; i < connections.length; i++) {\n      var connection = connections[i];\n\n      if (from !== to) {\n        this.connections.push(connection);\n      } else {\n        this.selfconns.push(connection);\n      }\n    }\n\n    return connections;\n  },\n\n  /**\r\n   * Disconnects the from node from the to node\r\n   */\n  disconnect: function disconnect(from, to) {\n    // Delete the connection in the network's connection array\n    var connections = from === to ? this.selfconns : this.connections;\n\n    for (var i = 0; i < connections.length; i++) {\n      var connection = connections[i];\n\n      if (connection.from === from && connection.to === to) {\n        if (connection.gater !== null) this.ungate(connection);\n        connections.splice(i, 1);\n        break;\n      }\n    } // Delete the connection at the sending and receiving neuron\n\n\n    from.disconnect(to);\n  },\n\n  /**\r\n   * Gate a connection with a node\r\n   */\n  gate: function gate(node, connection) {\n    if (this.nodes.indexOf(node) === -1) {\n      throw new Error('This node is not part of the network!');\n    } else if (connection.gater != null) {\n      if (config.warnings) console.warn('This connection is already gated!');\n      return;\n    }\n\n    node.gate(connection);\n    this.gates.push(connection);\n  },\n\n  /**\r\n   *  Remove the gate of a connection\r\n   */\n  ungate: function ungate(connection) {\n    var index = this.gates.indexOf(connection);\n\n    if (index === -1) {\n      throw new Error('This connection is not gated!');\n    }\n\n    this.gates.splice(index, 1);\n    connection.gater.ungate(connection);\n  },\n\n  /**\r\n   *  Removes a node from the network\r\n   */\n  remove: function remove(node) {\n    var index = this.nodes.indexOf(node);\n\n    if (index === -1) {\n      throw new Error('This node does not exist in the network!');\n    } // Keep track of gaters\n\n\n    var gaters = []; // Remove selfconnections from this.selfconns\n\n    this.disconnect(node, node); // Get all its inputting nodes\n\n    var inputs = [];\n\n    for (var i = node.connections[\"in\"].length - 1; i >= 0; i--) {\n      var connection = node.connections[\"in\"][i];\n\n      if (mutation.SUB_NODE.keep_gates && connection.gater !== null && connection.gater !== node) {\n        gaters.push(connection.gater);\n      }\n\n      inputs.push(connection.from);\n      this.disconnect(connection.from, node);\n    } // Get all its outputing nodes\n\n\n    var outputs = [];\n\n    for (i = node.connections.out.length - 1; i >= 0; i--) {\n      var _connection = node.connections.out[i];\n\n      if (mutation.SUB_NODE.keep_gates && _connection.gater !== null && _connection.gater !== node) {\n        gaters.push(_connection.gater);\n      }\n\n      outputs.push(_connection.to);\n      this.disconnect(node, _connection.to);\n    } // Connect the input nodes to the output nodes (if not already connected)\n\n\n    var connections = [];\n\n    for (i = 0; i < inputs.length; i++) {\n      var input = inputs[i];\n\n      for (var j = 0; j < outputs.length; j++) {\n        var output = outputs[j];\n\n        if (!input.isProjectingTo(output)) {\n          var conn = this.connect(input, output);\n          connections.push(conn[0]);\n        }\n      }\n    } // Gate random connections with gaters\n\n\n    for (i = 0; i < gaters.length; i++) {\n      if (connections.length === 0) break;\n      var gater = gaters[i];\n      var connIndex = Math.floor(Math.random() * connections.length);\n      this.gate(gater, connections[connIndex]);\n      connections.splice(connIndex, 1);\n    } // Remove gated connections gated by this node\n\n\n    for (i = node.connections.gated.length - 1; i >= 0; i--) {\n      var _conn = node.connections.gated[i];\n      this.ungate(_conn);\n    } // Remove selfconnection\n\n\n    this.disconnect(node, node); // Remove the node from this.nodes\n\n    this.nodes.splice(index, 1);\n  },\n\n  /**\r\n   * Mutates the network with the given method\r\n   */\n  mutate: function mutate(method) {\n    if (typeof method === 'undefined') {\n      throw new Error('No (correct) mutate method given!');\n    }\n\n    var i, j;\n    var mutationStart = performance.now();\n\n    switch (method) {\n      case mutation.ADD_NODE:\n        // Look for an existing connection and place a node in between\n        var connection = this.connections[Math.floor(Math.random() * this.connections.length)];\n        var gater = connection.gater;\n        this.disconnect(connection.from, connection.to); // Insert the new node right before the old connection.to\n\n        var toIndex = this.nodes.indexOf(connection.to);\n        var node = new Node('hidden'); // Random squash function\n\n        node.mutate(mutation.MOD_ACTIVATION); // Place it in this.nodes\n\n        var minBound = Math.min(toIndex, this.nodes.length - this.output);\n        this.nodes.splice(minBound, 0, node); // Now create two new connections\n\n        var newConn1 = this.connect(connection.from, node)[0];\n        var newConn2 = this.connect(node, connection.to)[0]; // Check if the original connection was gated\n\n        if (gater != null) {\n          this.gate(gater, Math.random() >= 0.5 ? newConn1 : newConn2);\n        }\n\n        break;\n\n      case mutation.SUB_NODE:\n        // Check if there are nodes left to remove\n        if (this.nodes.length === this.input + this.output) {\n          if (config.warnings) console.warn('No more nodes left to remove!');\n          break;\n        } // Select a node which isn't an input or output node\n\n\n        var index = Math.floor(Math.random() * (this.nodes.length - this.output - this.input) + this.input);\n        this.remove(this.nodes[index]);\n        break;\n\n      case mutation.ADD_CONN:\n        // Create an array of all uncreated (feedforward) connections\n        var available = [];\n\n        for (i = 0; i < this.nodes.length - this.output; i++) {\n          var _node = this.nodes[i];\n\n          for (j = Math.max(i + 1, this.input); j < this.nodes.length; j++) {\n            var _node2 = this.nodes[j];\n            if (!_node.isProjectingTo(_node2)) available.push([_node, _node2]);\n          }\n        }\n\n        if (available.length === 0) {\n          if (config.warnings) console.warn('No more connections to be made!');\n          break;\n        }\n\n        var pair = available[Math.floor(Math.random() * available.length)];\n        this.connect(pair[0], pair[1]);\n        break;\n\n      case mutation.SUB_CONN:\n        // List of possible connections that can be removed\n        var possible = [];\n\n        for (i = 0; i < this.connections.length; i++) {\n          var _conn2 = this.connections[i]; // Check if it is not disabling a node\n\n          if (_conn2.from.connections.out.length > 1 && _conn2.to.connections[\"in\"].length > 1 && this.nodes.indexOf(_conn2.to) > this.nodes.indexOf(_conn2.from)) {\n            possible.push(_conn2);\n          }\n        }\n\n        if (possible.length === 0) {\n          if (config.warnings) console.warn('No connections to remove!');\n          break;\n        }\n\n        var randomConn = possible[Math.floor(Math.random() * possible.length)];\n        this.disconnect(randomConn.from, randomConn.to);\n        break;\n\n      case mutation.MOD_WEIGHT:\n        var allconnections = this.connections.concat(this.selfconns);\n        var connection = allconnections[Math.floor(Math.random() * allconnections.length)];\n        var modification = Math.random() * (method.max - method.min) + method.min;\n        connection.weight += modification;\n        break;\n\n      case mutation.MOD_BIAS:\n        // Has no effect on input node, so they are excluded\n        var index = Math.floor(Math.random() * (this.nodes.length - this.input) + this.input);\n        var node = this.nodes[index];\n        node.mutate(method);\n        break;\n\n      case mutation.MOD_ACTIVATION:\n        // Has no effect on input node, so they are excluded\n        if (!method.mutateOutput && this.input + this.output === this.nodes.length) {\n          if (config.warnings) console.warn('No nodes that allow mutation of activation function');\n          break;\n        }\n\n        var index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);\n        var node = this.nodes[index];\n        node.mutate(method);\n        break;\n\n      case mutation.ADD_SELF_CONN:\n        // Check which nodes aren't selfconnected yet\n        var possible = [];\n\n        for (i = this.input; i < this.nodes.length; i++) {\n          var _node3 = this.nodes[i];\n\n          if (_node3.connections.self.weight === 0) {\n            possible.push(_node3);\n          }\n        }\n\n        if (possible.length === 0) {\n          if (config.warnings) console.warn('No more self-connections to add!');\n          break;\n        } // Select a random node\n\n\n        var node = possible[Math.floor(Math.random() * possible.length)]; // Connect it to himself\n\n        this.connect(node, node);\n        break;\n\n      case mutation.SUB_SELF_CONN:\n        if (this.selfconns.length === 0) {\n          if (config.warnings) console.warn('No more self-connections to remove!');\n          break;\n        }\n\n        var conn = this.selfconns[Math.floor(Math.random() * this.selfconns.length)];\n        this.disconnect(conn.from, conn.to);\n        break;\n\n      case mutation.ADD_GATE:\n        var allconnections = this.connections.concat(this.selfconns); // Create a list of all non-gated connections\n\n        var possible = [];\n\n        for (i = 0; i < allconnections.length; i++) {\n          var _conn3 = allconnections[i];\n\n          if (_conn3.gater === null) {\n            possible.push(_conn3);\n          }\n        }\n\n        if (possible.length === 0) {\n          if (config.warnings) console.warn('No more connections to gate!');\n          break;\n        } // Select a random gater node and connection, can't be gated by input\n\n\n        var index = Math.floor(Math.random() * (this.nodes.length - this.input) + this.input);\n        var node = this.nodes[index];\n        var conn = possible[Math.floor(Math.random() * possible.length)]; // Gate the connection with the node\n\n        this.gate(node, conn);\n        break;\n\n      case mutation.SUB_GATE:\n        // Select a random gated connection\n        if (this.gates.length === 0) {\n          if (config.warnings) console.warn('No more connections to ungate!');\n          break;\n        }\n\n        var index = Math.floor(Math.random() * this.gates.length);\n        var gatedconn = this.gates[index];\n        this.ungate(gatedconn);\n        break;\n\n      case mutation.ADD_BACK_CONN:\n        // Create an array of all uncreated (backfed) connections\n        var available = [];\n\n        for (i = this.input; i < this.nodes.length; i++) {\n          var _node4 = this.nodes[i];\n\n          for (j = this.input; j < i; j++) {\n            var _node5 = this.nodes[j];\n            if (!_node4.isProjectingTo(_node5)) available.push([_node4, _node5]);\n          }\n        }\n\n        if (available.length === 0) {\n          if (config.warnings) console.warn('No more connections to be made!');\n          break;\n        }\n\n        var pair = available[Math.floor(Math.random() * available.length)];\n        this.connect(pair[0], pair[1]);\n        break;\n\n      case mutation.SUB_BACK_CONN:\n        // List of possible connections that can be removed\n        var possible = [];\n\n        for (i = 0; i < this.connections.length; i++) {\n          var _conn4 = this.connections[i]; // Check if it is not disabling a node\n\n          if (_conn4.from.connections.out.length > 1 && _conn4.to.connections[\"in\"].length > 1 && this.nodes.indexOf(_conn4.from) > this.nodes.indexOf(_conn4.to)) {\n            possible.push(_conn4);\n          }\n        }\n\n        if (possible.length === 0) {\n          if (config.warnings) console.warn('No connections to remove!');\n          break;\n        }\n\n        var randomConn = possible[Math.floor(Math.random() * possible.length)];\n        this.disconnect(randomConn.from, randomConn.to);\n        break;\n\n      case mutation.SWAP_NODES:\n        // Has no effect on input node, so they are excluded\n        if (method.mutateOutput && this.nodes.length - this.input < 2 || !method.mutateOutput && this.nodes.length - this.input - this.output < 2) {\n          if (config.warnings) console.warn('No nodes that allow swapping of bias and activation function');\n          break;\n        }\n\n        var index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);\n        var node1 = this.nodes[index];\n        index = Math.floor(Math.random() * (this.nodes.length - (method.mutateOutput ? 0 : this.output) - this.input) + this.input);\n        var node2 = this.nodes[index];\n        var biasTemp = node1.bias;\n        var squashTemp = node1.squash;\n        node1.bias = node2.bias;\n        node1.squash = node2.squash;\n        node2.bias = biasTemp;\n        node2.squash = squashTemp;\n        break;\n    }\n\n    var mutationFinish = performance.now();\n    var diff = mutationFinish - mutationStart;\n    window['results']['generations'][window['generation']]['mutationTimes'].push({\n      method: method,\n      time: diff\n    });\n  },\n\n  /**\r\n   * Train the given set to this network\r\n   */\n  train: function train(set, options) {\n    if (set[0].input.length !== this.input || set[0].output.length !== this.output) {\n      throw new Error('Dataset input/output size should be same as network input/output size!');\n    }\n\n    options = options || {}; // Warning messages\n\n    if (typeof options.rate === 'undefined') {\n      if (config.warnings) console.warn('Using default learning rate, please define a rate!');\n    }\n\n    if (typeof options.iterations === 'undefined') {\n      if (config.warnings) console.warn('No target iterations given, running until error is reached!');\n    } // Read the options\n\n\n    var targetError = options.error || 0.05;\n    var cost = options.cost || methods.cost.MSE;\n    var baseRate = options.rate || 0.3;\n    var dropout = options.dropout || 0;\n    var momentum = options.momentum || 0;\n    var batchSize = options.batchSize || 1; // online learning\n\n    var ratePolicy = options.ratePolicy || methods.rate.FIXED();\n    var start = Date.now();\n\n    if (batchSize > set.length) {\n      throw new Error('Batch size must be smaller or equal to dataset length!');\n    } else if (typeof options.iterations === 'undefined' && typeof options.error === 'undefined') {\n      throw new Error('At least one of the following options must be specified: error, iterations');\n    } else if (typeof options.error === 'undefined') {\n      targetError = -1; // run until iterations\n    } else if (typeof options.iterations === 'undefined') {\n      options.iterations = 0; // run until target error\n    } // Save to network\n\n\n    this.dropout = dropout;\n\n    if (options.crossValidate) {\n      var numTrain = Math.ceil((1 - options.crossValidate.testSize) * set.length);\n      var trainSet = set.slice(0, numTrain);\n      var testSet = set.slice(numTrain);\n    } // Loops the training process\n\n\n    var currentRate = baseRate;\n    var iteration = 0;\n    var error = 1;\n    var i, j, x;\n\n    while (error > targetError && (options.iterations === 0 || iteration < options.iterations)) {\n      if (options.crossValidate && error <= options.crossValidate.testError) break;\n      iteration++; // Update the rate\n\n      currentRate = ratePolicy(baseRate, iteration); // Checks if cross validation is enabled\n\n      if (options.crossValidate) {\n        this._trainSet(trainSet, batchSize, currentRate, momentum, cost);\n\n        if (options.clear) this.clear();\n        error = this.test(testSet, cost).error;\n        if (options.clear) this.clear();\n      } else {\n        error = this._trainSet(set, batchSize, currentRate, momentum, cost);\n        if (options.clear) this.clear();\n      } // Checks for options such as scheduled logs and shuffling\n\n\n      if (options.shuffle) {\n        for (j, x, i = set.length; i; j = Math.floor(Math.random() * i), x = set[--i], set[i] = set[j], set[j] = x) {\n          ;\n        }\n      }\n\n      if (options.log && iteration % options.log === 0) {\n        console.log('iteration', iteration, 'error', error, 'rate', currentRate);\n      }\n\n      if (options.schedule && iteration % options.schedule.iterations === 0) {\n        options.schedule[\"function\"]({\n          error: error,\n          iteration: iteration\n        });\n      }\n    }\n\n    if (options.clear) this.clear();\n\n    if (dropout) {\n      for (i = 0; i < this.nodes.length; i++) {\n        if (this.nodes[i].type === 'hidden' || this.nodes[i].type === 'constant') {\n          this.nodes[i].mask = 1 - this.dropout;\n        }\n      }\n    }\n\n    return {\n      error: error,\n      iterations: iteration,\n      time: Date.now() - start\n    };\n  },\n\n  /**\r\n   * Performs one training epoch and returns the error\r\n   * private function used in this.train\r\n   */\n  _trainSet: function _trainSet(set, batchSize, currentRate, momentum, costFunction) {\n    var errorSum = 0;\n\n    for (var i = 0; i < set.length; i++) {\n      var input = set[i].input;\n      var target = set[i].output;\n      var update = !!((i + 1) % batchSize === 0 || i + 1 === set.length);\n      var output = this.activate(input, true);\n      this.propagate(currentRate, momentum, update, target);\n      errorSum += costFunction(target, output);\n    }\n\n    return errorSum / set.length;\n  },\n\n  /**\r\n   * Tests a set and returns the error and elapsed time\r\n   */\n  test: function test(set) {\n    var cost = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : methods.cost.MSE;\n    // Check if dropout is enabled, set correct mask\n    var i;\n\n    if (this.dropout) {\n      for (i = 0; i < this.nodes.length; i++) {\n        if (this.nodes[i].type === 'hidden' || this.nodes[i].type === 'constant') {\n          this.nodes[i].mask = 1 - this.dropout;\n        }\n      }\n    }\n\n    var error = 0;\n    var start = Date.now();\n\n    for (i = 0; i < set.length; i++) {\n      var input = set[i].input;\n      var target = set[i].output;\n      var output = this.noTraceActivate(input);\n      error += cost(target, output);\n    }\n\n    error /= set.length;\n    var results = {\n      error: error,\n      time: Date.now() - start\n    };\n    return results;\n  },\n\n  /**\r\n   * Creates a json that can be used to create a graph with d3 and webcola\r\n   */\n  graph: function graph(width, height) {\n    var input = 0;\n    var output = 0;\n    var json = {\n      nodes: [],\n      links: [],\n      constraints: [{\n        type: 'alignment',\n        axis: 'x',\n        offsets: []\n      }, {\n        type: 'alignment',\n        axis: 'y',\n        offsets: []\n      }]\n    };\n    var i;\n\n    for (i = 0; i < this.nodes.length; i++) {\n      var node = this.nodes[i];\n\n      if (node.type === 'input') {\n        if (this.input === 1) {\n          json.constraints[0].offsets.push({\n            node: i,\n            offset: 0\n          });\n        } else {\n          json.constraints[0].offsets.push({\n            node: i,\n            offset: 0.8 * width / (this.input - 1) * input++\n          });\n        }\n\n        json.constraints[1].offsets.push({\n          node: i,\n          offset: 0\n        });\n      } else if (node.type === 'output') {\n        if (this.output === 1) {\n          json.constraints[0].offsets.push({\n            node: i,\n            offset: 0\n          });\n        } else {\n          json.constraints[0].offsets.push({\n            node: i,\n            offset: 0.8 * width / (this.output - 1) * output++\n          });\n        }\n\n        json.constraints[1].offsets.push({\n          node: i,\n          offset: -0.8 * height\n        });\n      }\n\n      json.nodes.push({\n        id: i,\n        name: node.type === 'hidden' ? node.squash.name : node.type.toUpperCase(),\n        activation: node.activation,\n        bias: node.bias\n      });\n    }\n\n    var connections = this.connections.concat(this.selfconns);\n\n    for (i = 0; i < connections.length; i++) {\n      var connection = connections[i];\n\n      if (connection.gater == null) {\n        json.links.push({\n          source: this.nodes.indexOf(connection.from),\n          target: this.nodes.indexOf(connection.to),\n          weight: connection.weight\n        });\n      } else {\n        // Add a gater 'node'\n        var index = json.nodes.length;\n        json.nodes.push({\n          id: index,\n          activation: connection.gater.activation,\n          name: 'GATE'\n        });\n        json.links.push({\n          source: this.nodes.indexOf(connection.from),\n          target: index,\n          weight: 1 / 2 * connection.weight\n        });\n        json.links.push({\n          source: index,\n          target: this.nodes.indexOf(connection.to),\n          weight: 1 / 2 * connection.weight\n        });\n        json.links.push({\n          source: this.nodes.indexOf(connection.gater),\n          target: index,\n          weight: connection.gater.activation,\n          gate: true\n        });\n      }\n    }\n\n    return json;\n  },\n\n  /**\r\n   * Convert the network to a json object\r\n   */\n  toJSON: function toJSON() {\n    var json = {\n      nodes: [],\n      connections: [],\n      input: this.input,\n      output: this.output,\n      dropout: this.dropout\n    }; // So we don't have to use expensive .indexOf()\n\n    var i;\n\n    for (i = 0; i < this.nodes.length; i++) {\n      this.nodes[i].index = i;\n    }\n\n    for (i = 0; i < this.nodes.length; i++) {\n      var node = this.nodes[i];\n      var tojson = node.toJSON();\n      tojson.index = i;\n      json.nodes.push(tojson);\n\n      if (node.connections.self.weight !== 0) {\n        var _tojson = node.connections.self.toJSON();\n\n        _tojson.from = i;\n        _tojson.to = i;\n        _tojson.gater = node.connections.self.gater != null ? node.connections.self.gater.index : null;\n        json.connections.push(_tojson);\n      }\n    }\n\n    for (i = 0; i < this.connections.length; i++) {\n      var conn = this.connections[i];\n\n      var _tojson2 = conn.toJSON();\n\n      _tojson2.from = conn.from.index;\n      _tojson2.to = conn.to.index;\n      _tojson2.gater = conn.gater != null ? conn.gater.index : null;\n      json.connections.push(_tojson2);\n    }\n\n    return json;\n  },\n\n  /**\r\n   * Sets the value of a property for every node in this network\r\n   */\n  set: function set(values) {\n    for (var i = 0; i < this.nodes.length; i++) {\n      this.nodes[i].bias = values.bias || this.nodes[i].bias;\n      this.nodes[i].squash = values.squash || this.nodes[i].squash;\n    }\n  },\n\n  /**\r\n   * Evolves the network to reach a lower error on a dataset\r\n   */\n  evolve: function () {\n    var _evolve = _asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee(set, options) {\n      var targetError, growth, cost, amount, threads, start, fitnessFunction, converted, workers, i, neat, error, bestFitness, bestGenome, fittest, fitness;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(set[0].input.length !== this.input || set[0].output.length !== this.output)) {\n                _context.next = 2;\n                break;\n              }\n\n              throw new Error('Dataset input/output size should be same as network input/output size!');\n\n            case 2:\n              // Read the options\n              options = options || {};\n              targetError = typeof options.error !== 'undefined' ? options.error : 0.05;\n              growth = typeof options.growth !== 'undefined' ? options.growth : 0.0001;\n              cost = options.cost || methods.cost.MSE;\n              amount = options.amount || 1;\n              threads = options.threads;\n\n              if (typeof threads === 'undefined') {\n                if (typeof window === 'undefined') {\n                  // Node.js\n                  threads = __webpack_require__(/*! os */ \"./node_modules/os-browserify/browser.js\").cpus().length;\n                } else {\n                  // Browser\n                  threads = navigator.hardwareConcurrency;\n                }\n              }\n\n              start = Date.now();\n\n              if (!(typeof options.iterations === 'undefined' && typeof options.error === 'undefined')) {\n                _context.next = 14;\n                break;\n              }\n\n              throw new Error('At least one of the following options must be specified: error, iterations');\n\n            case 14:\n              if (typeof options.error === 'undefined') {\n                targetError = -1; // run until iterations\n              } else if (typeof options.iterations === 'undefined') {\n                options.iterations = 0; // run until target error\n              }\n\n            case 15:\n              if (threads === 1) {\n                // Create the fitness function\n                fitnessFunction = function fitnessFunction(genome) {\n                  var score = 0;\n\n                  for (var i = 0; i < amount; i++) {\n                    score -= genome.test(set, cost).error;\n                  }\n\n                  score -= (genome.nodes.length - genome.input - genome.output + genome.connections.length + genome.gates.length) * growth;\n                  score = isNaN(score) ? -Infinity : score; // this can cause problems with fitness proportionate selection\n\n                  return score / amount;\n                };\n              } else {\n                // Serialize the dataset\n                converted = multi.serializeDataSet(set); // Create workers, send datasets\n\n                workers = [];\n\n                if (typeof window === 'undefined') {\n                  for (i = 0; i < threads; i++) {\n                    workers.push(new multi.workers.node.TestWorker(converted, cost));\n                  }\n                } else {\n                  for (i = 0; i < threads; i++) {\n                    workers.push(new multi.workers.browser.TestWorker(converted, cost));\n                  }\n                }\n\n                fitnessFunction = function fitnessFunction(population) {\n                  return new Promise(function (resolve, reject) {\n                    // Create a queue\n                    var queue = population.slice();\n                    var done = 0; // Start worker function\n\n                    var startWorker = function startWorker(worker) {\n                      if (!queue.length) {\n                        if (++done === threads) resolve();\n                        return;\n                      }\n\n                      var genome = queue.shift();\n                      worker.evaluate(genome).then(function (result) {\n                        genome.score = -result;\n                        genome.score -= (genome.nodes.length - genome.input - genome.output + genome.connections.length + genome.gates.length) * growth;\n                        genome.score = isNaN(parseFloat(result)) ? -Infinity : genome.score;\n                        startWorker(worker);\n                      });\n                    };\n\n                    for (var i = 0; i < workers.length; i++) {\n                      startWorker(workers[i]);\n                    }\n                  });\n                };\n\n                options.fitnessPopulation = true;\n              } // Intialise the NEAT instance\n\n\n              options.network = this;\n              neat = new Neat(this.input, this.output, fitnessFunction, options);\n              error = -Infinity;\n              bestFitness = -Infinity;\n\n            case 20:\n              if (!(error < -targetError && (options.iterations === 0 || neat.generation < options.iterations))) {\n                _context.next = 31;\n                break;\n              }\n\n              _context.next = 23;\n              return neat.evolve();\n\n            case 23:\n              fittest = _context.sent;\n              fitness = fittest.score;\n              error = fitness + (fittest.nodes.length - fittest.input - fittest.output + fittest.connections.length + fittest.gates.length) * growth;\n\n              if (fitness > bestFitness) {\n                bestFitness = fitness;\n                bestGenome = fittest;\n              }\n\n              if (options.log && neat.generation % options.log === 0) {\n                console.log('iteration', neat.generation, 'fitness', fitness, 'error', -error);\n              }\n\n              if (options.schedule && neat.generation % options.schedule.iterations === 0) {\n                options.schedule[\"function\"]({\n                  fitness: fitness,\n                  error: -error,\n                  iteration: neat.generation\n                });\n              }\n\n              _context.next = 20;\n              break;\n\n            case 31:\n              if (threads > 1) {\n                for (i = 0; i < workers.length; i++) {\n                  workers[i].terminate();\n                }\n              }\n\n              if (typeof bestGenome !== 'undefined') {\n                this.nodes = bestGenome.nodes;\n                this.connections = bestGenome.connections;\n                this.selfconns = bestGenome.selfconns;\n                this.gates = bestGenome.gates;\n                if (options.clear) this.clear();\n              }\n\n              return _context.abrupt(\"return\", {\n                error: -error,\n                iterations: neat.generation,\n                time: Date.now() - start\n              });\n\n            case 34:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function evolve(_x, _x2) {\n      return _evolve.apply(this, arguments);\n    }\n\n    return evolve;\n  }(),\n\n  /**\r\n   * Creates a standalone function of the network which can be run without the\r\n   * need of a library\r\n   */\n  standalone: function standalone() {\n    var present = [];\n    var activations = [];\n    var states = [];\n    var lines = [];\n    var functions = [];\n    var i;\n\n    for (i = 0; i < this.input; i++) {\n      var node = this.nodes[i];\n      activations.push(node.activation);\n      states.push(node.state);\n    }\n\n    lines.push('for(var i = 0; i < input.length; i++) A[i] = input[i];'); // So we don't have to use expensive .indexOf()\n\n    for (i = 0; i < this.nodes.length; i++) {\n      this.nodes[i].index = i;\n    }\n\n    for (i = this.input; i < this.nodes.length; i++) {\n      var _node6 = this.nodes[i];\n      activations.push(_node6.activation);\n      states.push(_node6.state);\n      var functionIndex = present.indexOf(_node6.squash.name);\n\n      if (functionIndex === -1) {\n        functionIndex = present.length;\n        present.push(_node6.squash.name);\n        functions.push(_node6.squash.toString());\n      }\n\n      var incoming = [];\n\n      for (var j = 0; j < _node6.connections[\"in\"].length; j++) {\n        var conn = _node6.connections[\"in\"][j];\n        var computation = \"A[\".concat(conn.from.index, \"] * \").concat(conn.weight);\n\n        if (conn.gater != null) {\n          computation += \" * A[\".concat(conn.gater.index, \"]\");\n        }\n\n        incoming.push(computation);\n      }\n\n      if (_node6.connections.self.weight) {\n        var _conn5 = _node6.connections.self;\n\n        var _computation = \"S[\".concat(i, \"] * \").concat(_conn5.weight);\n\n        if (_conn5.gater != null) {\n          _computation += \" * A[\".concat(_conn5.gater.index, \"]\");\n        }\n\n        incoming.push(_computation);\n      }\n\n      var line1 = \"S[\".concat(i, \"] = \").concat(incoming.join(' + '), \" + \").concat(_node6.bias, \";\");\n      var line2 = \"A[\".concat(i, \"] = F[\").concat(functionIndex, \"](S[\").concat(i, \"])\").concat(!_node6.mask ? ' * ' + _node6.mask : '', \";\");\n      lines.push(line1);\n      lines.push(line2);\n    }\n\n    var output = [];\n\n    for (i = this.nodes.length - this.output; i < this.nodes.length; i++) {\n      output.push(\"A[\".concat(i, \"]\"));\n    }\n\n    output = \"return [\".concat(output.join(','), \"];\");\n    lines.push(output);\n    var total = '';\n    total += \"var F = [\".concat(functions.toString(), \"];\\r\\n\");\n    total += \"var A = [\".concat(activations.toString(), \"];\\r\\n\");\n    total += \"var S = [\".concat(states.toString(), \"];\\r\\n\");\n    total += \"function activate(input){\\r\\n\".concat(lines.join('\\r\\n'), \"\\r\\n}\");\n    return total;\n  },\n\n  /**\r\n   * Serialize to send to workers efficiently\r\n   */\n  serialize: function serialize() {\n    var activations = [];\n    var states = [];\n    var conns = [];\n    var squashes = ['LOGISTIC', 'TANH', 'IDENTITY', 'STEP', 'RELU', 'SOFTSIGN', 'SINUSOID', 'GAUSSIAN', 'BENT_IDENTITY', 'BIPOLAR', 'BIPOLAR_SIGMOID', 'HARD_TANH', 'ABSOLUTE', 'INVERSE', 'SELU'];\n    conns.push(this.input);\n    conns.push(this.output);\n    var i;\n\n    for (i = 0; i < this.nodes.length; i++) {\n      var node = this.nodes[i];\n      node.index = i;\n      activations.push(node.activation);\n      states.push(node.state);\n    }\n\n    for (i = this.input; i < this.nodes.length; i++) {\n      var _node7 = this.nodes[i];\n      conns.push(_node7.index);\n      conns.push(_node7.bias);\n      conns.push(squashes.indexOf(_node7.squash.name));\n      conns.push(_node7.connections.self.weight);\n      conns.push(_node7.connections.self.gater == null ? -1 : _node7.connections.self.gater.index);\n\n      for (var j = 0; j < _node7.connections[\"in\"].length; j++) {\n        var conn = _node7.connections[\"in\"][j];\n        conns.push(conn.from.index);\n        conns.push(conn.weight);\n        conns.push(conn.gater == null ? -1 : conn.gater.index);\n      }\n\n      conns.push(-2); // stop token -> next node\n    }\n\n    return [activations, states, conns];\n  }\n};\n/**\r\n * Convert a json object to a network\r\n */\n\nNetwork.fromJSON = function (json) {\n  var network = new Network(json.input, json.output);\n  network.dropout = json.dropout;\n  network.nodes = [];\n  network.connections = [];\n  var i;\n\n  for (i = 0; i < json.nodes.length; i++) {\n    network.nodes.push(Node.fromJSON(json.nodes[i]));\n  }\n\n  for (i = 0; i < json.connections.length; i++) {\n    var conn = json.connections[i];\n    var connection = network.connect(network.nodes[conn.from], network.nodes[conn.to])[0];\n    connection.weight = conn.weight;\n\n    if (conn.gater != null) {\n      network.gate(network.nodes[conn.gater], connection);\n    }\n  }\n\n  return network;\n};\n/**\r\n * Merge two networks into one\r\n */\n\n\nNetwork.merge = function (network1, network2) {\n  // Create a copy of the networks\n  network1 = Network.fromJSON(network1.toJSON());\n  network2 = Network.fromJSON(network2.toJSON()); // Check if output and input size are the same\n\n  if (network1.output !== network2.input) {\n    throw new Error('Output size of network1 should be the same as the input size of network2!');\n  } // Redirect all connections from network2 input from network1 output\n\n\n  var i;\n\n  for (i = 0; i < network2.connections.length; i++) {\n    var conn = network2.connections[i];\n\n    if (conn.from.type === 'input') {\n      var index = network2.nodes.indexOf(conn.from); // redirect\n\n      conn.from = network1.nodes[network1.nodes.length - 1 - index];\n    }\n  } // Delete input nodes of network2\n\n\n  for (i = network2.input - 1; i >= 0; i--) {\n    network2.nodes.splice(i, 1);\n  } // Change the node type of network1's output nodes (now hidden)\n\n\n  for (i = network1.nodes.length - network1.output; i < network1.nodes.length; i++) {\n    network1.nodes[i].type = 'hidden';\n  } // Create one network from both networks\n\n\n  network1.connections = network1.connections.concat(network2.connections);\n  network1.nodes = network1.nodes.concat(network2.nodes);\n  return network1;\n};\n/**\r\n * Create an offspring from two parent networks\r\n */\n\n\nNetwork.crossOver = function (network1, network2, equal) {\n  if (network1.input !== network2.input || network1.output !== network2.output) {\n    throw new Error(\"Networks don't have the same input/output size!\");\n  }\n\n  var startCrossover = performance.now(); // Initialise offspring\n\n  var offspring = new Network(network1.input, network1.output);\n  offspring.connections = [];\n  offspring.nodes = []; // Save scores and create a copy\n\n  var score1 = network1.score || 0;\n  var score2 = network2.score || 0; // Determine offspring node size\n\n  var size;\n\n  if (equal || score1 === score2) {\n    var max = Math.max(network1.nodes.length, network2.nodes.length);\n    var min = Math.min(network1.nodes.length, network2.nodes.length);\n    size = Math.floor(Math.random() * (max - min + 1) + min);\n  } else if (score1 > score2) {\n    size = network1.nodes.length;\n  } else {\n    size = network2.nodes.length;\n  } // Rename some variables for easier reading\n\n\n  var outputSize = network1.output; // Set indexes so we don't need indexOf\n\n  var i;\n\n  for (i = 0; i < network1.nodes.length; i++) {\n    network1.nodes[i].index = i;\n  }\n\n  for (i = 0; i < network2.nodes.length; i++) {\n    network2.nodes[i].index = i;\n  } // Assign nodes from parents to offspring\n\n\n  for (i = 0; i < size; i++) {\n    // Determine if an output node is needed\n    var node;\n\n    if (i < size - outputSize) {\n      var random = Math.random();\n      node = random >= 0.5 ? network1.nodes[i] : network2.nodes[i];\n      var other = random < 0.5 ? network1.nodes[i] : network2.nodes[i];\n\n      if (typeof node === 'undefined' || node.type === 'output') {\n        node = other;\n      }\n    } else {\n      if (Math.random() >= 0.5) {\n        node = network1.nodes[network1.nodes.length + i - size];\n      } else {\n        node = network2.nodes[network2.nodes.length + i - size];\n      }\n    }\n\n    var newNode = new Node();\n    newNode.bias = node.bias;\n    newNode.squash = node.squash;\n    newNode.type = node.type;\n    offspring.nodes.push(newNode);\n  } // Create arrays of connection genes\n\n\n  var n1conns = {};\n  var n2conns = {}; // Normal connections\n\n  for (i = 0; i < network1.connections.length; i++) {\n    var conn = network1.connections[i];\n    var data = {\n      weight: conn.weight,\n      from: conn.from.index,\n      to: conn.to.index,\n      gater: conn.gater != null ? conn.gater.index : -1\n    };\n    n1conns[Connection.innovationID(data.from, data.to)] = data;\n  } // Selfconnections\n\n\n  for (i = 0; i < network1.selfconns.length; i++) {\n    var _conn6 = network1.selfconns[i];\n    var _data = {\n      weight: _conn6.weight,\n      from: _conn6.from.index,\n      to: _conn6.to.index,\n      gater: _conn6.gater != null ? _conn6.gater.index : -1\n    };\n    n1conns[Connection.innovationID(_data.from, _data.to)] = _data;\n  } // Normal connections\n\n\n  for (i = 0; i < network2.connections.length; i++) {\n    var _conn7 = network2.connections[i];\n    var _data2 = {\n      weight: _conn7.weight,\n      from: _conn7.from.index,\n      to: _conn7.to.index,\n      gater: _conn7.gater != null ? _conn7.gater.index : -1\n    };\n    n2conns[Connection.innovationID(_data2.from, _data2.to)] = _data2;\n  } // Selfconnections\n\n\n  for (i = 0; i < network2.selfconns.length; i++) {\n    var _conn8 = network2.selfconns[i];\n    var _data3 = {\n      weight: _conn8.weight,\n      from: _conn8.from.index,\n      to: _conn8.to.index,\n      gater: _conn8.gater != null ? _conn8.gater.index : -1\n    };\n    n2conns[Connection.innovationID(_data3.from, _data3.to)] = _data3;\n  } // Split common conn genes from disjoint or excess conn genes\n\n\n  var connections = [];\n  var keys1 = Object.keys(n1conns);\n  var keys2 = Object.keys(n2conns);\n\n  for (i = keys1.length - 1; i >= 0; i--) {\n    // Common gene\n    if (typeof n2conns[keys1[i]] !== 'undefined') {\n      var _conn9 = Math.random() >= 0.5 ? n1conns[keys1[i]] : n2conns[keys1[i]];\n\n      connections.push(_conn9); // Because deleting is expensive, just set it to some value\n\n      n2conns[keys1[i]] = undefined;\n    } else if (score1 >= score2 || equal) {\n      connections.push(n1conns[keys1[i]]);\n    }\n  } // Excess/disjoint gene\n\n\n  if (score2 >= score1 || equal) {\n    for (i = 0; i < keys2.length; i++) {\n      if (typeof n2conns[keys2[i]] !== 'undefined') {\n        connections.push(n2conns[keys2[i]]);\n      }\n    }\n  } // Add common conn genes uniformly\n\n\n  for (i = 0; i < connections.length; i++) {\n    var connData = connections[i];\n\n    if (connData.to < size && connData.from < size) {\n      var from = offspring.nodes[connData.from];\n      var to = offspring.nodes[connData.to];\n      var _conn10 = offspring.connect(from, to)[0];\n      _conn10.weight = connData.weight;\n\n      if (connData.gater !== -1 && connData.gater < size) {\n        offspring.gate(offspring.nodes[connData.gater], _conn10);\n      }\n    }\n  }\n\n  var finishCrossover = performance.now();\n  var diff = finishCrossover - startCrossover;\n  window['results']['generations'][window['generation']]['crossoverTimes'].push(diff);\n  return offspring;\n};\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/architecture/network.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/architecture/node.js":
/*!*******************************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/architecture/node.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Export */\nmodule.exports = Node;\n/* Import */\n\nvar methods = __webpack_require__(/*! ../methods/methods */ \"./assets/js/libs/neataptic_vanilla/src/methods/methods.js\");\n\nvar Connection = __webpack_require__(/*! ./connection */ \"./assets/js/libs/neataptic_vanilla/src/architecture/connection.js\");\n\nvar config = __webpack_require__(/*! ../config */ \"./assets/js/libs/neataptic_vanilla/src/config.js\");\n/*******************************************************************************\r\n                                         NODE\r\n*******************************************************************************/\n\n\nfunction Node(type) {\n  this.bias = type === 'input' ? 0 : Math.random() * 0.2 - 0.1;\n  this.squash = methods.activation.LOGISTIC;\n  this.type = type || 'hidden';\n  this.activation = 0;\n  this.state = 0;\n  this.old = 0; // For dropout\n\n  this.mask = 1; // For tracking momentum\n\n  this.previousDeltaBias = 0; // Batch training\n\n  this.totalDeltaBias = 0;\n  this.connections = {\n    \"in\": [],\n    out: [],\n    gated: [],\n    self: new Connection(this, this, 0)\n  }; // Data for backpropagation\n\n  this.error = {\n    responsibility: 0,\n    projected: 0,\n    gated: 0\n  };\n}\n\nNode.prototype = {\n  /**\r\n   * Activates the node\r\n   */\n  activate: function activate(input) {\n    // Check if an input is given\n    if (typeof input !== 'undefined') {\n      this.activation = input;\n      return this.activation;\n    }\n\n    this.old = this.state; // All activation sources coming from the node itself\n\n    this.state = this.connections.self.gain * this.connections.self.weight * this.state + this.bias; // Activation sources coming from connections\n\n    var i;\n\n    for (i = 0; i < this.connections[\"in\"].length; i++) {\n      var connection = this.connections[\"in\"][i];\n      this.state += connection.from.activation * connection.weight * connection.gain;\n    } // Squash the values received\n\n\n    this.activation = this.squash(this.state) * this.mask;\n    this.derivative = this.squash(this.state, true); // Update traces\n\n    var nodes = [];\n    var influences = [];\n\n    for (i = 0; i < this.connections.gated.length; i++) {\n      var conn = this.connections.gated[i];\n      var node = conn.to;\n      var index = nodes.indexOf(node);\n\n      if (index > -1) {\n        influences[index] += conn.weight * conn.from.activation;\n      } else {\n        nodes.push(node);\n        influences.push(conn.weight * conn.from.activation + (node.connections.self.gater === this ? node.old : 0));\n      } // Adjust the gain to this nodes' activation\n\n\n      conn.gain = this.activation;\n    }\n\n    for (i = 0; i < this.connections[\"in\"].length; i++) {\n      var _connection = this.connections[\"in\"][i]; // Elegibility trace\n\n      _connection.elegibility = this.connections.self.gain * this.connections.self.weight * _connection.elegibility + _connection.from.activation * _connection.gain; // Extended trace\n\n      for (var j = 0; j < nodes.length; j++) {\n        var _node = nodes[j];\n        var influence = influences[j];\n\n        var _index = _connection.xtrace.nodes.indexOf(_node);\n\n        if (_index > -1) {\n          _connection.xtrace.values[_index] = _node.connections.self.gain * _node.connections.self.weight * _connection.xtrace.values[_index] + this.derivative * _connection.elegibility * influence;\n        } else {\n          // Does not exist there yet, might be through mutation\n          _connection.xtrace.nodes.push(_node);\n\n          _connection.xtrace.values.push(this.derivative * _connection.elegibility * influence);\n        }\n      }\n    }\n\n    return this.activation;\n  },\n\n  /**\r\n   * Activates the node without calculating elegibility traces and such\r\n   */\n  noTraceActivate: function noTraceActivate(input) {\n    // Check if an input is given\n    if (typeof input !== 'undefined') {\n      this.activation = input;\n      return this.activation;\n    } // All activation sources coming from the node itself\n\n\n    this.state = this.connections.self.gain * this.connections.self.weight * this.state + this.bias; // Activation sources coming from connections\n\n    var i;\n\n    for (i = 0; i < this.connections[\"in\"].length; i++) {\n      var connection = this.connections[\"in\"][i];\n      this.state += connection.from.activation * connection.weight * connection.gain;\n    } // Squash the values received\n\n\n    this.activation = this.squash(this.state);\n\n    for (i = 0; i < this.connections.gated.length; i++) {\n      this.connections.gated[i].gain = this.activation;\n    }\n\n    return this.activation;\n  },\n\n  /**\r\n   * Back-propagate the error, aka learn\r\n   */\n  propagate: function propagate(rate, momentum, update, target) {\n    momentum = momentum || 0;\n    rate = rate || 0.3; // Error accumulator\n\n    var error = 0; // Output nodes get their error from the enviroment\n\n    if (this.type === 'output') {\n      this.error.responsibility = this.error.projected = target - this.activation;\n    } else {\n      // the rest of the nodes compute their error responsibilities by backpropagation\n      // error responsibilities from all the connections projected from this node\n      var i;\n\n      for (i = 0; i < this.connections.out.length; i++) {\n        var connection = this.connections.out[i];\n        var node = connection.to; // Eq. 21\n\n        error += node.error.responsibility * connection.weight * connection.gain;\n      } // Projected error responsibility\n\n\n      this.error.projected = this.derivative * error; // Error responsibilities from all connections gated by this neuron\n\n      error = 0;\n\n      for (i = 0; i < this.connections.gated.length; i++) {\n        var conn = this.connections.gated[i];\n        var _node2 = conn.to;\n        var influence = _node2.connections.self.gater === this ? _node2.old : 0;\n        influence += conn.weight * conn.from.activation;\n        error += _node2.error.responsibility * influence;\n      } // Gated error responsibility\n\n\n      this.error.gated = this.derivative * error; // Error responsibility\n\n      this.error.responsibility = this.error.projected + this.error.gated;\n    }\n\n    if (this.type === 'constant') return; // Adjust all the node's incoming connections\n\n    for (i = 0; i < this.connections[\"in\"].length; i++) {\n      var _connection2 = this.connections[\"in\"][i];\n      var gradient = this.error.projected * _connection2.elegibility;\n\n      for (var j = 0; j < _connection2.xtrace.nodes.length; j++) {\n        var _node3 = _connection2.xtrace.nodes[j];\n        var value = _connection2.xtrace.values[j];\n        gradient += _node3.error.responsibility * value;\n      } // Adjust weight\n\n\n      var deltaWeight = rate * gradient * this.mask;\n      _connection2.totalDeltaWeight += deltaWeight;\n\n      if (update) {\n        _connection2.totalDeltaWeight += momentum * _connection2.previousDeltaWeight;\n        _connection2.weight += _connection2.totalDeltaWeight;\n        _connection2.previousDeltaWeight = _connection2.totalDeltaWeight;\n        _connection2.totalDeltaWeight = 0;\n      }\n    } // Adjust bias\n\n\n    var deltaBias = rate * this.error.responsibility;\n    this.totalDeltaBias += deltaBias;\n\n    if (update) {\n      this.totalDeltaBias += momentum * this.previousDeltaBias;\n      this.bias += this.totalDeltaBias;\n      this.previousDeltaBias = this.totalDeltaBias;\n      this.totalDeltaBias = 0;\n    }\n  },\n\n  /**\r\n   * Creates a connection from this node to the given node\r\n   */\n  connect: function connect(target, weight) {\n    var connections = [];\n\n    if (typeof target.bias !== 'undefined') {\n      // must be a node!\n      if (target === this) {\n        // Turn on the self connection by setting the weight\n        if (this.connections.self.weight !== 0) {\n          if (config.warnings) console.warn('This connection already exists!');\n        } else {\n          this.connections.self.weight = weight || 1;\n        }\n\n        connections.push(this.connections.self);\n      } else if (this.isProjectingTo(target)) {\n        throw new Error('Already projecting a connection to this node!');\n      } else {\n        var connection = new Connection(this, target, weight);\n        target.connections[\"in\"].push(connection);\n        this.connections.out.push(connection);\n        connections.push(connection);\n      }\n    } else {\n      // should be a group\n      for (var i = 0; i < target.nodes.length; i++) {\n        var _connection3 = new Connection(this, target.nodes[i], weight);\n\n        target.nodes[i].connections[\"in\"].push(_connection3);\n        this.connections.out.push(_connection3);\n        target.connections[\"in\"].push(_connection3);\n        connections.push(_connection3);\n      }\n    }\n\n    return connections;\n  },\n\n  /**\r\n   * Disconnects this node from the other node\r\n   */\n  disconnect: function disconnect(node, twosided) {\n    if (this === node) {\n      this.connections.self.weight = 0;\n      return;\n    }\n\n    for (var i = 0; i < this.connections.out.length; i++) {\n      var conn = this.connections.out[i];\n\n      if (conn.to === node) {\n        this.connections.out.splice(i, 1);\n        var j = conn.to.connections[\"in\"].indexOf(conn);\n        conn.to.connections[\"in\"].splice(j, 1);\n        if (conn.gater !== null) conn.gater.ungate(conn);\n        break;\n      }\n    }\n\n    if (twosided) {\n      node.disconnect(this);\n    }\n  },\n\n  /**\r\n   * Make this node gate a connection\r\n   */\n  gate: function gate(connections) {\n    if (!Array.isArray(connections)) {\n      connections = [connections];\n    }\n\n    for (var i = 0; i < connections.length; i++) {\n      var connection = connections[i];\n      this.connections.gated.push(connection);\n      connection.gater = this;\n    }\n  },\n\n  /**\r\n   * Removes the gates from this node from the given connection(s)\r\n   */\n  ungate: function ungate(connections) {\n    if (!Array.isArray(connections)) {\n      connections = [connections];\n    }\n\n    for (var i = connections.length - 1; i >= 0; i--) {\n      var connection = connections[i];\n      var index = this.connections.gated.indexOf(connection);\n      this.connections.gated.splice(index, 1);\n      connection.gater = null;\n      connection.gain = 1;\n    }\n  },\n\n  /**\r\n   * Clear the context of the node\r\n   */\n  clear: function clear() {\n    for (var i = 0; i < this.connections[\"in\"].length; i++) {\n      var connection = this.connections[\"in\"][i];\n      connection.elegibility = 0;\n      connection.xtrace = {\n        nodes: [],\n        values: []\n      };\n    }\n\n    for (i = 0; i < this.connections.gated.length; i++) {\n      var conn = this.connections.gated[i];\n      conn.gain = 0;\n    }\n\n    this.error.responsibility = this.error.projected = this.error.gated = 0;\n    this.old = this.state = this.activation = 0;\n  },\n\n  /**\r\n   * Mutates the node with the given method\r\n   */\n  mutate: function mutate(method) {\n    if (typeof method === 'undefined') {\n      throw new Error('No mutate method given!');\n    } else if (!(method.name in methods.mutation)) {\n      throw new Error('This method does not exist!');\n    }\n\n    switch (method) {\n      case methods.mutation.MOD_ACTIVATION:\n        // Can't be the same squash\n        var squash = method.allowed[(method.allowed.indexOf(this.squash) + Math.floor(Math.random() * (method.allowed.length - 1)) + 1) % method.allowed.length];\n        this.squash = squash;\n        break;\n\n      case methods.mutation.MOD_BIAS:\n        var modification = Math.random() * (method.max - method.min) + method.min;\n        this.bias += modification;\n        break;\n    }\n  },\n\n  /**\r\n   * Checks if this node is projecting to the given node\r\n   */\n  isProjectingTo: function isProjectingTo(node) {\n    if (node === this && this.connections.self.weight !== 0) return true;\n\n    for (var i = 0; i < this.connections.out.length; i++) {\n      var conn = this.connections.out[i];\n\n      if (conn.to === node) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Checks if the given node is projecting to this node\r\n   */\n  isProjectedBy: function isProjectedBy(node) {\n    if (node === this && this.connections.self.weight !== 0) return true;\n\n    for (var i = 0; i < this.connections[\"in\"].length; i++) {\n      var conn = this.connections[\"in\"][i];\n\n      if (conn.from === node) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /**\r\n   * Converts the node to a json object\r\n   */\n  toJSON: function toJSON() {\n    var json = {\n      bias: this.bias,\n      type: this.type,\n      squash: this.squash.name,\n      mask: this.mask\n    };\n    return json;\n  }\n};\n/**\r\n * Convert a json object to a node\r\n */\n\nNode.fromJSON = function (json) {\n  var node = new Node();\n  node.bias = json.bias;\n  node.type = json.type;\n  node.mask = json.mask;\n  node.squash = methods.activation[json.squash];\n  return node;\n};\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/architecture/node.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/config.js":
/*!********************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/config.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                      CONFIG\r\n*******************************************************************************/\n// Config\nvar config = {\n  warnings: false\n};\n/* Export */\n\nmodule.exports = config;\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/config.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/methods/activation.js":
/*!********************************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/methods/activation.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                  ACTIVATION FUNCTIONS\r\n*******************************************************************************/\n// https://en.wikipedia.org/wiki/Activation_function\n// https://stats.stackexchange.com/questions/115258/comprehensive-list-of-activation-functions-in-neural-networks-with-pros-cons\nvar activation = {\n  LOGISTIC: function LOGISTIC(x, derivate) {\n    var fx = 1 / (1 + Math.exp(-x));\n    if (!derivate) return fx;\n    return fx * (1 - fx);\n  },\n  TANH: function TANH(x, derivate) {\n    if (derivate) return 1 - Math.pow(Math.tanh(x), 2);\n    return Math.tanh(x);\n  },\n  IDENTITY: function IDENTITY(x, derivate) {\n    return derivate ? 1 : x;\n  },\n  STEP: function STEP(x, derivate) {\n    return derivate ? 0 : x > 0 ? 1 : 0;\n  },\n  RELU: function RELU(x, derivate) {\n    if (derivate) return x > 0 ? 1 : 0;\n    return x > 0 ? x : 0;\n  },\n  SOFTSIGN: function SOFTSIGN(x, derivate) {\n    var d = 1 + Math.abs(x);\n    if (derivate) return x / Math.pow(d, 2);\n    return x / d;\n  },\n  SINUSOID: function SINUSOID(x, derivate) {\n    if (derivate) return Math.cos(x);\n    return Math.sin(x);\n  },\n  GAUSSIAN: function GAUSSIAN(x, derivate) {\n    var d = Math.exp(-Math.pow(x, 2));\n    if (derivate) return -2 * x * d;\n    return d;\n  },\n  BENT_IDENTITY: function BENT_IDENTITY(x, derivate) {\n    var d = Math.sqrt(Math.pow(x, 2) + 1);\n    if (derivate) return x / (2 * d) + 1;\n    return (d - 1) / 2 + x;\n  },\n  BIPOLAR: function BIPOLAR(x, derivate) {\n    return derivate ? 0 : x > 0 ? 1 : -1;\n  },\n  BIPOLAR_SIGMOID: function BIPOLAR_SIGMOID(x, derivate) {\n    var d = 2 / (1 + Math.exp(-x)) - 1;\n    if (derivate) return 1 / 2 * (1 + d) * (1 - d);\n    return d;\n  },\n  HARD_TANH: function HARD_TANH(x, derivate) {\n    if (derivate) return x > -1 && x < 1 ? 1 : 0;\n    return Math.max(-1, Math.min(1, x));\n  },\n  ABSOLUTE: function ABSOLUTE(x, derivate) {\n    if (derivate) return x < 0 ? -1 : 1;\n    return Math.abs(x);\n  },\n  INVERSE: function INVERSE(x, derivate) {\n    if (derivate) return -1;\n    return 1 - x;\n  },\n  // https://arxiv.org/pdf/1706.02515.pdf\n  SELU: function SELU(x, derivate) {\n    var alpha = 1.6732632423543772848170429916717;\n    var scale = 1.0507009873554804934193349852946;\n    var fx = x > 0 ? x : alpha * Math.exp(x) - alpha;\n\n    if (derivate) {\n      return x > 0 ? scale : (fx + alpha) * scale;\n    }\n\n    return fx * scale;\n  }\n};\n/* Export */\n\nmodule.exports = activation;\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/methods/activation.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/methods/connection.js":
/*!********************************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/methods/connection.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                    CONNECTION\r\n*******************************************************************************/\n// Specifies in what manner two groups are connected\nvar connection = {\n  ALL_TO_ALL: {\n    name: 'OUTPUT'\n  },\n  ALL_TO_ELSE: {\n    name: 'INPUT'\n  },\n  ONE_TO_ONE: {\n    name: 'SELF'\n  }\n};\n/* Export */\n\nmodule.exports = connection;\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/methods/connection.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/methods/cost.js":
/*!**************************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/methods/cost.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                    COST FUNCTIONS\r\n*******************************************************************************/\n// https://en.wikipedia.org/wiki/Loss_function\nvar cost = {\n  // Cross entropy error\n  CROSS_ENTROPY: function CROSS_ENTROPY(target, output) {\n    var error = 0;\n\n    for (var i = 0; i < output.length; i++) {\n      // Avoid negative and zero numbers, use 1e-15 http://bit.ly/2p5W29A\n      error -= target[i] * Math.log(Math.max(output[i], 1e-15)) + (1 - target[i]) * Math.log(1 - Math.max(output[i], 1e-15));\n    }\n\n    return error / output.length;\n  },\n  // Mean Squared Error\n  MSE: function MSE(target, output) {\n    var error = 0;\n\n    for (var i = 0; i < output.length; i++) {\n      error += Math.pow(target[i] - output[i], 2);\n    }\n\n    return error / output.length;\n  },\n  // Binary error\n  BINARY: function BINARY(target, output) {\n    var misses = 0;\n\n    for (var i = 0; i < output.length; i++) {\n      misses += Math.round(target[i] * 2) !== Math.round(output[i] * 2);\n    }\n\n    return misses;\n  },\n  // Mean Absolute Error\n  MAE: function MAE(target, output) {\n    var error = 0;\n\n    for (var i = 0; i < output.length; i++) {\n      error += Math.abs(target[i] - output[i]);\n    }\n\n    return error / output.length;\n  },\n  // Mean Absolute Percentage Error\n  MAPE: function MAPE(target, output) {\n    var error = 0;\n\n    for (var i = 0; i < output.length; i++) {\n      error += Math.abs((output[i] - target[i]) / Math.max(target[i], 1e-15));\n    }\n\n    return error / output.length;\n  },\n  // Mean Squared Logarithmic Error\n  MSLE: function MSLE(target, output) {\n    var error = 0;\n\n    for (var i = 0; i < output.length; i++) {\n      error += Math.log(Math.max(target[i], 1e-15)) - Math.log(Math.max(output[i], 1e-15));\n    }\n\n    return error;\n  },\n  // Hinge loss, for classifiers\n  HINGE: function HINGE(target, output) {\n    var error = 0;\n\n    for (var i = 0; i < output.length; i++) {\n      error += Math.max(0, 1 - target[i] * output[i]);\n    }\n\n    return error;\n  }\n};\n/* Export */\n\nmodule.exports = cost;\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/methods/cost.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/methods/crossover.js":
/*!*******************************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/methods/crossover.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                      CROSSOVER\r\n*******************************************************************************/\n// https://en.wikipedia.org/wiki/Crossover_(genetic_algorithm)\nvar crossover = {\n  SINGLE_POINT: {\n    name: 'SINGLE_POINT',\n    config: [0.4]\n  },\n  TWO_POINT: {\n    name: 'TWO_POINT',\n    config: [0.4, 0.9]\n  },\n  UNIFORM: {\n    name: 'UNIFORM'\n  },\n  AVERAGE: {\n    name: 'AVERAGE'\n  }\n};\n/* Export */\n\nmodule.exports = crossover;\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/methods/crossover.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/methods/gating.js":
/*!****************************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/methods/gating.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                    GATING\r\n*******************************************************************************/\n// Specifies how to gate a connection between two groups of multiple neurons\nvar gating = {\n  OUTPUT: {\n    name: 'OUTPUT'\n  },\n  INPUT: {\n    name: 'INPUT'\n  },\n  SELF: {\n    name: 'SELF'\n  }\n};\n/* Export */\n\nmodule.exports = gating;\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/methods/gating.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/methods/methods.js":
/*!*****************************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/methods/methods.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*******************************************************************************\r\n                                  METHODS\r\n*******************************************************************************/\nvar methods = {\n  activation: __webpack_require__(/*! ./activation */ \"./assets/js/libs/neataptic_vanilla/src/methods/activation.js\"),\n  mutation: __webpack_require__(/*! ./mutation */ \"./assets/js/libs/neataptic_vanilla/src/methods/mutation.js\"),\n  selection: __webpack_require__(/*! ./selection */ \"./assets/js/libs/neataptic_vanilla/src/methods/selection.js\"),\n  crossover: __webpack_require__(/*! ./crossover */ \"./assets/js/libs/neataptic_vanilla/src/methods/crossover.js\"),\n  cost: __webpack_require__(/*! ./cost */ \"./assets/js/libs/neataptic_vanilla/src/methods/cost.js\"),\n  gating: __webpack_require__(/*! ./gating */ \"./assets/js/libs/neataptic_vanilla/src/methods/gating.js\"),\n  connection: __webpack_require__(/*! ./connection */ \"./assets/js/libs/neataptic_vanilla/src/methods/connection.js\"),\n  rate: __webpack_require__(/*! ./rate */ \"./assets/js/libs/neataptic_vanilla/src/methods/rate.js\")\n};\n/** Export */\n\nmodule.exports = methods;\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/methods/methods.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/methods/mutation.js":
/*!******************************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/methods/mutation.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Import */\nvar activation = __webpack_require__(/*! ./activation */ \"./assets/js/libs/neataptic_vanilla/src/methods/activation.js\");\n/*******************************************************************************\r\n                                      MUTATION\r\n*******************************************************************************/\n// https://en.wikipedia.org/wiki/mutation_(genetic_algorithm)\n\n\nvar mutation = {\n  ADD_NODE: {\n    name: 'ADD_NODE'\n  },\n  SUB_NODE: {\n    name: 'SUB_NODE',\n    keep_gates: true\n  },\n  ADD_CONN: {\n    name: 'ADD_CONN'\n  },\n  SUB_CONN: {\n    name: 'REMOVE_CONN'\n  },\n  MOD_WEIGHT: {\n    name: 'MOD_WEIGHT',\n    min: -1,\n    max: 1\n  },\n  MOD_BIAS: {\n    name: 'MOD_BIAS',\n    min: -1,\n    max: 1\n  },\n  MOD_ACTIVATION: {\n    name: 'MOD_ACTIVATION',\n    mutateOutput: true,\n    allowed: [activation.LOGISTIC, activation.TANH, activation.RELU, activation.IDENTITY, activation.STEP, activation.SOFTSIGN, activation.SINUSOID, activation.GAUSSIAN, activation.BENT_IDENTITY, activation.BIPOLAR, activation.BIPOLAR_SIGMOID, activation.HARD_TANH, activation.ABSOLUTE, activation.INVERSE, activation.SELU]\n  },\n  ADD_SELF_CONN: {\n    name: 'ADD_SELF_CONN'\n  },\n  SUB_SELF_CONN: {\n    name: 'SUB_SELF_CONN'\n  },\n  ADD_GATE: {\n    name: 'ADD_GATE'\n  },\n  SUB_GATE: {\n    name: 'SUB_GATE'\n  },\n  ADD_BACK_CONN: {\n    name: 'ADD_BACK_CONN'\n  },\n  SUB_BACK_CONN: {\n    name: 'SUB_BACK_CONN'\n  },\n  SWAP_NODES: {\n    name: 'SWAP_NODES',\n    mutateOutput: true\n  }\n};\nmutation.ALL = [mutation.ADD_NODE, mutation.SUB_NODE, mutation.ADD_CONN, mutation.SUB_CONN, mutation.MOD_WEIGHT, mutation.MOD_BIAS, mutation.MOD_ACTIVATION, mutation.ADD_GATE, mutation.SUB_GATE, mutation.ADD_SELF_CONN, mutation.SUB_SELF_CONN, mutation.ADD_BACK_CONN, mutation.SUB_BACK_CONN, mutation.SWAP_NODES];\nmutation.FFW = [mutation.ADD_NODE, mutation.SUB_NODE, mutation.ADD_CONN, mutation.SUB_CONN, mutation.MOD_WEIGHT, mutation.MOD_BIAS, mutation.MOD_ACTIVATION, mutation.SWAP_NODES];\n/* Export */\n\nmodule.exports = mutation;\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/methods/mutation.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/methods/rate.js":
/*!**************************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/methods/rate.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                      RATE\r\n*******************************************************************************/\n// https://stackoverflow.com/questions/30033096/what-is-lr-policy-in-caffe/30045244\nvar rate = {\n  FIXED: function FIXED() {\n    var func = function func(baseRate, iteration) {\n      return baseRate;\n    };\n\n    return func;\n  },\n  STEP: function STEP(gamma, stepSize) {\n    gamma = gamma || 0.9;\n    stepSize = stepSize || 100;\n\n    var func = function func(baseRate, iteration) {\n      return baseRate * Math.pow(gamma, Math.floor(iteration / stepSize));\n    };\n\n    return func;\n  },\n  EXP: function EXP(gamma) {\n    gamma = gamma || 0.999;\n\n    var func = function func(baseRate, iteration) {\n      return baseRate * Math.pow(gamma, iteration);\n    };\n\n    return func;\n  },\n  INV: function INV(gamma, power) {\n    gamma = gamma || 0.001;\n    power = power || 2;\n\n    var func = function func(baseRate, iteration) {\n      return baseRate * Math.pow(1 + gamma * iteration, -power);\n    };\n\n    return func;\n  }\n};\n/* Export */\n\nmodule.exports = rate;\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/methods/rate.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/methods/selection.js":
/*!*******************************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/methods/selection.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*******************************************************************************\r\n                                      SELECTION\r\n*******************************************************************************/\n// https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)\nvar selection = {\n  FITNESS_PROPORTIONATE: {\n    name: 'FITNESS_PROPORTIONATE'\n  },\n  POWER: {\n    name: 'POWER',\n    power: 4\n  },\n  TOURNAMENT: {\n    name: 'TOURNAMENT',\n    size: 5,\n    probability: 0.5\n  }\n};\n/* Export */\n\nmodule.exports = selection;\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/methods/selection.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/multithreading/multi.js":
/*!**********************************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/multithreading/multi.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*******************************************************************************\r\n                                MULTITHREADING\r\n*******************************************************************************/\nvar multi = {\n  /** Workers */\n  workers: __webpack_require__(/*! ./workers/workers */ \"./assets/js/libs/neataptic_vanilla/src/multithreading/workers/workers.js\"),\n\n  /** Serializes a dataset */\n  serializeDataSet: function serializeDataSet(dataSet) {\n    var serialized = [dataSet[0].input.length, dataSet[0].output.length];\n\n    for (var i = 0; i < dataSet.length; i++) {\n      var j;\n\n      for (j = 0; j < serialized[0]; j++) {\n        serialized.push(dataSet[i].input[j]);\n      }\n\n      for (j = 0; j < serialized[1]; j++) {\n        serialized.push(dataSet[i].output[j]);\n      }\n    }\n\n    return serialized;\n  },\n\n  /** Activate a serialized network */\n  activateSerializedNetwork: function activateSerializedNetwork(input, A, S, data, F) {\n    for (var i = 0; i < data[0]; i++) {\n      A[i] = input[i];\n    }\n\n    for (i = 2; i < data.length; i++) {\n      var index = data[i++];\n      var bias = data[i++];\n      var squash = data[i++];\n      var selfweight = data[i++];\n      var selfgater = data[i++];\n      S[index] = (selfgater === -1 ? 1 : A[selfgater]) * selfweight * S[index] + bias;\n\n      while (data[i] !== -2) {\n        S[index] += A[data[i++]] * data[i++] * (data[i++] === -1 ? 1 : A[data[i - 1]]);\n      }\n\n      A[index] = F[squash](S[index]);\n    }\n\n    var output = [];\n\n    for (i = A.length - data[1]; i < A.length; i++) {\n      output.push(A[i]);\n    }\n\n    return output;\n  },\n\n  /** Deserializes a dataset to an array of arrays */\n  deserializeDataSet: function deserializeDataSet(serializedSet) {\n    var set = [];\n    var sampleSize = serializedSet[0] + serializedSet[1];\n\n    for (var i = 0; i < (serializedSet.length - 2) / sampleSize; i++) {\n      var input = [];\n\n      for (var j = 2 + i * sampleSize; j < 2 + i * sampleSize + serializedSet[0]; j++) {\n        input.push(serializedSet[j]);\n      }\n\n      var output = [];\n\n      for (j = 2 + i * sampleSize + serializedSet[0]; j < 2 + i * sampleSize + sampleSize; j++) {\n        output.push(serializedSet[j]);\n      }\n\n      set.push(input);\n      set.push(output);\n    }\n\n    return set;\n  },\n\n  /** A list of compiled activation functions in a certain order */\n  activations: [function (x) {\n    return 1 / (1 + Math.exp(-x));\n  }, function (x) {\n    return Math.tanh(x);\n  }, function (x) {\n    return x;\n  }, function (x) {\n    return x > 0 ? 1 : 0;\n  }, function (x) {\n    return x > 0 ? x : 0;\n  }, function (x) {\n    return x / (1 + Math.abs(x));\n  }, function (x) {\n    return Math.sin(x);\n  }, function (x) {\n    return Math.exp(-Math.pow(x, 2));\n  }, function (x) {\n    return (Math.sqrt(Math.pow(x, 2) + 1) - 1) / 2 + x;\n  }, function (x) {\n    return x > 0 ? 1 : -1;\n  }, function (x) {\n    return 2 / (1 + Math.exp(-x)) - 1;\n  }, function (x) {\n    return Math.max(-1, Math.min(1, x));\n  }, function (x) {\n    return Math.abs(x);\n  }, function (x) {\n    return 1 - x;\n  }, function (x) {\n    var a = 1.6732632423543772848170429916717;\n    return (x > 0 ? x : a * Math.exp(x) - a) * 1.0507009873554804934193349852946;\n  }]\n};\n\nmulti.testSerializedSet = function (set, cost, A, S, data, F) {\n  // Calculate how much samples are in the set\n  var error = 0;\n\n  for (var i = 0; i < set.length; i += 2) {\n    var output = multi.activateSerializedNetwork(set[i], A, S, data, F);\n    error += cost(set[i + 1], output);\n  }\n\n  return error / (set.length / 2);\n};\n/* Export */\n\n\nfor (var i in multi) {\n  module.exports[i] = multi[i];\n}\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/multithreading/multi.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/multithreading/workers/browser/testworker.js":
/*!*******************************************************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/multithreading/workers/browser/testworker.js ***!
  \*******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* Export */\nmodule.exports = TestWorker;\n/* Import */\n\nvar multi = __webpack_require__(/*! ../../multi */ \"./assets/js/libs/neataptic_vanilla/src/multithreading/multi.js\");\n/*******************************************************************************\r\n                                WEBWORKER\r\n*******************************************************************************/\n\n\nfunction TestWorker(dataSet, cost) {\n  var blob = new Blob([this._createBlobString(cost)]);\n  this.url = window.URL.createObjectURL(blob);\n  this.worker = new Worker(this.url);\n  var data = {\n    set: new Float64Array(dataSet).buffer\n  };\n  this.worker.postMessage(data, [data.set]);\n}\n\nTestWorker.prototype = {\n  evaluate: function evaluate(network) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var serialized = network.serialize();\n      var data = {\n        activations: new Float64Array(serialized[0]).buffer,\n        states: new Float64Array(serialized[1]).buffer,\n        conns: new Float64Array(serialized[2]).buffer\n      };\n\n      _this.worker.onmessage = function (e) {\n        var error = new Float64Array(e.data.buffer)[0];\n        resolve(error);\n      };\n\n      _this.worker.postMessage(data, [data.activations, data.states, data.conns]);\n    });\n  },\n  terminate: function terminate() {\n    this.worker.terminate();\n    window.URL.revokeObjectURL(this.url);\n  },\n  _createBlobString: function _createBlobString(cost) {\n    var source = \"\\n      var F = [\".concat(multi.activations.toString(), \"];\\n      var cost = \").concat(cost.toString(), \";\\n      var multi = {\\n        deserializeDataSet: \").concat(multi.deserializeDataSet.toString(), \",\\n        testSerializedSet: \").concat(multi.testSerializedSet.toString(), \",\\n        activateSerializedNetwork: \").concat(multi.activateSerializedNetwork.toString(), \"\\n      };\\n\\n      this.onmessage = function (e) {\\n        if(typeof e.data.set === 'undefined'){\\n          var A = new Float64Array(e.data.activations);\\n          var S = new Float64Array(e.data.states);\\n          var data = new Float64Array(e.data.conns);\\n\\n          var error = multi.testSerializedSet(set, cost, A, S, data, F);\\n\\n          var answer = { buffer: new Float64Array([error ]).buffer };\\n          postMessage(answer, [answer.buffer]);\\n        } else {\\n          set = multi.deserializeDataSet(new Float64Array(e.data.set));\\n        }\\n      };\");\n    return source;\n  }\n};\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/multithreading/workers/browser/testworker.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/multithreading/workers/node/testworker.js":
/*!****************************************************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/multithreading/workers/node/testworker.js ***!
  \****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(__dirname) {/* Export */\nmodule.exports = TestWorker;\n/* Import */\n\nvar cp = __webpack_require__(/*! child_process */ \"./node_modules/node-libs-browser/mock/empty.js\");\n\nvar path = __webpack_require__(/*! path */ \"./node_modules/path-browserify/index.js\");\n/*******************************************************************************\r\n                                WEBWORKER\r\n*******************************************************************************/\n\n\nfunction TestWorker(dataSet, cost) {\n  this.worker = cp.fork(path.join(__dirname, '/worker'));\n  this.worker.send({\n    set: dataSet,\n    cost: cost.name\n  });\n}\n\nTestWorker.prototype = {\n  evaluate: function evaluate(network) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var serialized = network.serialize();\n      var data = {\n        activations: serialized[0],\n        states: serialized[1],\n        conns: serialized[2]\n      };\n      var _that = _this.worker;\n\n      _this.worker.on('message', function callback(e) {\n        _that.removeListener('message', callback);\n\n        resolve(e);\n      });\n\n      _this.worker.send(data);\n    });\n  },\n  terminate: function terminate() {\n    this.worker.kill();\n  }\n};\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/multithreading/workers/node/testworker.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/multithreading/workers/workers.js":
/*!********************************************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/multithreading/workers/workers.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*******************************************************************************\r\n                                  WORKERS\r\n*******************************************************************************/\nvar workers = {\n  node: {\n    TestWorker: __webpack_require__(/*! ./node/testworker */ \"./assets/js/libs/neataptic_vanilla/src/multithreading/workers/node/testworker.js\")\n  },\n  browser: {\n    TestWorker: __webpack_require__(/*! ./browser/testworker */ \"./assets/js/libs/neataptic_vanilla/src/multithreading/workers/browser/testworker.js\")\n  }\n};\n/** Export */\n\nmodule.exports = workers;\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/multithreading/workers/workers.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/neat.js":
/*!******************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/neat.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n/* Export */\nmodule.exports = Neat;\n/* Import */\n\nvar Network = __webpack_require__(/*! ./architecture/network */ \"./assets/js/libs/neataptic_vanilla/src/architecture/network.js\");\n\nvar methods = __webpack_require__(/*! ./methods/methods */ \"./assets/js/libs/neataptic_vanilla/src/methods/methods.js\");\n\nvar config = __webpack_require__(/*! ./config */ \"./assets/js/libs/neataptic_vanilla/src/config.js\");\n/* Easier variable naming */\n\n\nvar selection = methods.selection;\n/*******************************************************************************\r\n                                         NEAT\r\n*******************************************************************************/\n\nfunction Neat(input, output, fitness, options) {\n  console.log(\"VANILLA\");\n  this.input = input; // The input size of the networks\n\n  this.output = output; // The output size of the networks\n\n  this.fitness = fitness; // The fitness function to evaluate the networks\n  // Configure options\n\n  options = options || {};\n  this.equal = options.equal || false;\n  this.clear = options.clear || false;\n  this.popsize = options.popsize || 50;\n  this.elitism = options.elitism || 0;\n  this.provenance = options.provenance || 0;\n  this.mutationRate = options.mutationRate || 0.3;\n  this.mutationAmount = options.mutationAmount || 1;\n  this.fitnessPopulation = options.fitnessPopulation || false;\n  this.selection = options.selection || methods.selection.POWER;\n  this.crossover = options.crossover || [methods.crossover.SINGLE_POINT, methods.crossover.TWO_POINT, methods.crossover.UNIFORM, methods.crossover.AVERAGE];\n  this.mutation = options.mutation || methods.mutation.FFW;\n  this.template = options.network || false;\n  this.maxNodes = options.maxNodes || Infinity;\n  this.maxConns = options.maxConns || Infinity;\n  this.maxGates = options.maxGates || Infinity; // Custom mutation selection function if given\n\n  this.selectMutationMethod = typeof options.mutationSelection === 'function' ? options.mutationSelection.bind(this) : this.selectMutationMethod; // Generation counter\n\n  this.generation = 0; // Initialise the genomes\n\n  this.createPool(this.template);\n}\n\nNeat.prototype = {\n  /**\r\n   * Create the initial pool of genomes\r\n   */\n  createPool: function createPool(network) {\n    this.population = [];\n\n    for (var i = 0; i < this.popsize; i++) {\n      var copy;\n\n      if (this.template) {\n        copy = Network.fromJSON(network.toJSON());\n      } else {\n        copy = new Network(this.input, this.output);\n      }\n\n      copy.score = undefined;\n      this.population.push(copy);\n    }\n  },\n\n  /**\r\n   * Evaluates, selects, breeds and mutates population\r\n   */\n  evolve: function () {\n    var _evolve = _asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee() {\n      var _this$population;\n\n      var fittest, newPopulation, elitists, i;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (!(typeof this.population[this.population.length - 1].score === 'undefined')) {\n                _context.next = 3;\n                break;\n              }\n\n              _context.next = 3;\n              return this.evaluate();\n\n            case 3:\n              this.sort();\n              fittest = Network.fromJSON(this.population[0].toJSON());\n              fittest.score = this.population[0].score;\n              newPopulation = []; // Elitism\n\n              elitists = [];\n\n              for (i = 0; i < this.elitism; i++) {\n                elitists.push(this.population[i]);\n              } // Provenance\n\n\n              for (i = 0; i < this.provenance; i++) {\n                newPopulation.push(Network.fromJSON(this.template.toJSON()));\n              } // Breed the next individuals\n\n\n              for (i = 0; i < this.popsize - this.elitism - this.provenance; i++) {\n                newPopulation.push(this.getOffspring());\n              } // Replace the old population with the new population\n\n\n              this.population = newPopulation;\n              this.mutate();\n\n              (_this$population = this.population).push.apply(_this$population, elitists); // Reset the scores\n\n\n              for (i = 0; i < this.population.length; i++) {\n                this.population[i].score = undefined;\n              }\n\n              this.generation++;\n              return _context.abrupt(\"return\", fittest);\n\n            case 17:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function evolve() {\n      return _evolve.apply(this, arguments);\n    }\n\n    return evolve;\n  }(),\n\n  /**\r\n   * Breeds two parents into an offspring, population MUST be sorted\r\n   */\n  getOffspring: function getOffspring() {\n    var parent1 = this.getParent();\n    var parent2 = this.getParent();\n    return Network.crossOver(parent1, parent2, this.equal);\n  },\n\n  /**\r\n   * Selects a random mutation method for a genome according to the parameters\r\n   */\n  selectMutationMethod: function selectMutationMethod(genome) {\n    var mutationMethod = this.mutation[Math.floor(Math.random() * this.mutation.length)];\n\n    if (mutationMethod === methods.mutation.ADD_NODE && genome.nodes.length >= this.maxNodes) {\n      if (config.warnings) console.warn('maxNodes exceeded!');\n      return;\n    }\n\n    if (mutationMethod === methods.mutation.ADD_CONN && genome.connections.length >= this.maxConns) {\n      if (config.warnings) console.warn('maxConns exceeded!');\n      return;\n    }\n\n    if (mutationMethod === methods.mutation.ADD_GATE && genome.gates.length >= this.maxGates) {\n      if (config.warnings) console.warn('maxGates exceeded!');\n      return;\n    }\n\n    return mutationMethod;\n  },\n\n  /**\r\n   * Mutates the given (or current) population\r\n   */\n  mutate: function mutate() {\n    // Elitist genomes should not be included\n    for (var i = 0; i < this.population.length; i++) {\n      if (Math.random() <= this.mutationRate) {\n        for (var j = 0; j < this.mutationAmount; j++) {\n          var mutationMethod = this.selectMutationMethod(this.population[i]);\n          this.population[i].mutate(mutationMethod);\n        }\n      }\n    }\n  },\n\n  /**\r\n   * Evaluates the current population\r\n   */\n  evaluate: function () {\n    var _evaluate = _asyncToGenerator(\n    /*#__PURE__*/\n    regeneratorRuntime.mark(function _callee2() {\n      var i, genome;\n      return regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!this.fitnessPopulation) {\n                _context2.next = 6;\n                break;\n              }\n\n              if (this.clear) {\n                for (i = 0; i < this.population.length; i++) {\n                  this.population[i].clear();\n                }\n              }\n\n              _context2.next = 4;\n              return this.fitness(this.population);\n\n            case 4:\n              _context2.next = 16;\n              break;\n\n            case 6:\n              i = 0;\n\n            case 7:\n              if (!(i < this.population.length)) {\n                _context2.next = 16;\n                break;\n              }\n\n              genome = this.population[i];\n              if (this.clear) genome.clear();\n              _context2.next = 12;\n              return this.fitness(genome);\n\n            case 12:\n              genome.score = _context2.sent;\n\n            case 13:\n              i++;\n              _context2.next = 7;\n              break;\n\n            case 16:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    function evaluate() {\n      return _evaluate.apply(this, arguments);\n    }\n\n    return evaluate;\n  }(),\n\n  /**\r\n   * Sorts the population by score\r\n   */\n  sort: function sort() {\n    this.population.sort(function (a, b) {\n      return b.score - a.score;\n    });\n  },\n\n  /**\r\n   * Returns the fittest genome of the current population\r\n   */\n  getFittest: function getFittest() {\n    // Check if evaluated\n    if (typeof this.population[this.population.length - 1].score === 'undefined') {\n      this.evaluate();\n    }\n\n    if (this.population[0].score < this.population[1].score) {\n      this.sort();\n    }\n\n    return this.population[0];\n  },\n\n  /**\r\n   * Returns the average fitness of the current population\r\n   */\n  getAverage: function getAverage() {\n    if (typeof this.population[this.population.length - 1].score === 'undefined') {\n      this.evaluate();\n    }\n\n    var score = 0;\n\n    for (var i = 0; i < this.population.length; i++) {\n      score += this.population[i].score;\n    }\n\n    return score / this.population.length;\n  },\n\n  /**\r\n   * Gets a genome based on the selection function\r\n   * @return {Network} genome\r\n   */\n  getParent: function getParent() {\n    var i;\n\n    switch (this.selection) {\n      case selection.POWER:\n        if (this.population[0].score < this.population[1].score) this.sort();\n        var index = Math.floor(Math.pow(Math.random(), this.selection.power) * this.population.length);\n        return this.population[index];\n\n      case selection.FITNESS_PROPORTIONATE:\n        // As negative fitnesses are possible\n        // https://stackoverflow.com/questions/16186686/genetic-algorithm-handling-negative-fitness-values\n        // this is unnecessarily run for every individual, should be changed\n        var totalFitness = 0;\n        var minimalFitness = 0;\n\n        for (i = 0; i < this.population.length; i++) {\n          var score = this.population[i].score;\n          minimalFitness = score < minimalFitness ? score : minimalFitness;\n          totalFitness += score;\n        }\n\n        minimalFitness = Math.abs(minimalFitness);\n        totalFitness += minimalFitness * this.population.length;\n        var random = Math.random() * totalFitness;\n        var value = 0;\n\n        for (i = 0; i < this.population.length; i++) {\n          var genome = this.population[i];\n          value += genome.score + minimalFitness;\n          if (random < value) return genome;\n        } // if all scores equal, return random genome\n\n\n        return this.population[Math.floor(Math.random() * this.population.length)];\n\n      case selection.TOURNAMENT:\n        if (this.selection.size > this.popsize) {\n          throw new Error('Your tournament size should be lower than the population size, please change methods.selection.TOURNAMENT.size');\n        } // Create a tournament\n\n\n        var individuals = [];\n\n        for (i = 0; i < this.selection.size; i++) {\n          var _random = this.population[Math.floor(Math.random() * this.population.length)];\n          individuals.push(_random);\n        } // Sort the tournament individuals by score\n\n\n        individuals.sort(function (a, b) {\n          return b.score - a.score;\n        }); // Select an individual\n\n        for (i = 0; i < this.selection.size; i++) {\n          if (Math.random() < this.selection.probability || i === this.selection.size - 1) {\n            return individuals[i];\n          }\n        }\n\n    }\n  },\n\n  /**\r\n   * Export the current population to a json object\r\n   */\n  \"export\": function _export() {\n    var json = [];\n\n    for (var i = 0; i < this.population.length; i++) {\n      var genome = this.population[i];\n      json.push(genome.toJSON());\n    }\n\n    return json;\n  },\n\n  /**\r\n   * Import population from a json object\r\n   */\n  \"import\": function _import(json) {\n    var population = [];\n\n    for (var i = 0; i < json.length; i++) {\n      var genome = json[i];\n      population.push(Network.fromJSON(genome));\n    }\n\n    this.population = population;\n    this.popsize = population.length;\n  }\n};\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/neat.js?");

/***/ }),

/***/ "./assets/js/libs/neataptic_vanilla/src/neataptic.js":
/*!***********************************************************!*\
  !*** ./assets/js/libs/neataptic_vanilla/src/neataptic.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar Neataptic = {\n  methods: __webpack_require__(/*! ./methods/methods */ \"./assets/js/libs/neataptic_vanilla/src/methods/methods.js\"),\n  Connection: __webpack_require__(/*! ./architecture/connection */ \"./assets/js/libs/neataptic_vanilla/src/architecture/connection.js\"),\n  architect: __webpack_require__(/*! ./architecture/architect */ \"./assets/js/libs/neataptic_vanilla/src/architecture/architect.js\"),\n  Network: __webpack_require__(/*! ./architecture/network */ \"./assets/js/libs/neataptic_vanilla/src/architecture/network.js\"),\n  config: __webpack_require__(/*! ./config */ \"./assets/js/libs/neataptic_vanilla/src/config.js\"),\n  Group: __webpack_require__(/*! ./architecture/group */ \"./assets/js/libs/neataptic_vanilla/src/architecture/group.js\"),\n  Layer: __webpack_require__(/*! ./architecture/layer */ \"./assets/js/libs/neataptic_vanilla/src/architecture/layer.js\"),\n  Node: __webpack_require__(/*! ./architecture/node */ \"./assets/js/libs/neataptic_vanilla/src/architecture/node.js\"),\n  Neat: __webpack_require__(/*! ./neat */ \"./assets/js/libs/neataptic_vanilla/src/neat.js\"),\n  multi: __webpack_require__(/*! ./multithreading/multi */ \"./assets/js/libs/neataptic_vanilla/src/multithreading/multi.js\")\n}; // CommonJS & AMD\n\nif (true) {\n  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return Neataptic;\n  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} // Node.js\n\n\nif ( true && module.exports) {\n  module.exports = Neataptic;\n} // Browser\n\n\nif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === 'object') {\n  (function () {\n    var old = window['neataptic'];\n\n    Neataptic.ninja = function () {\n      window['neataptic'] = old;\n      return Neataptic;\n    };\n  })();\n\n  window['neataptic'] = Neataptic;\n}\n\n//# sourceURL=webpack:///./assets/js/libs/neataptic_vanilla/src/neataptic.js?");

/***/ }),

/***/ "./assets/js/sketches/index.js":
/*!*************************************!*\
  !*** ./assets/js/sketches/index.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return sketch; });\nvar initNeat,\n    startEvaluation,\n    endEvaluation,\n    iterations,\n    HEIGHT,\n    WIDTH,\n    maxGenerations = null;\nfunction sketch(p) {\n  var iteration = 0;\n  var active = false;\n  /**\n   * Core P5.js functions\n   */\n\n  p.setup = function () {\n    window['p'] = p;\n    p.createCanvas(WIDTH, HEIGHT);\n    initNeat();\n    startEvaluation();\n\n    if (active) {\n      p.loop();\n    } else {\n      p.noLoop();\n    }\n  };\n\n  p.draw = function () {\n    p.clear();\n    p.squareGrid();\n\n    if (active && window['generation'] <= maxGenerations) {\n      if (iteration === iterations) {\n        endEvaluation();\n        iteration = 0;\n      }\n\n      window['players'].forEach(function (player) {\n        player.update();\n        player.show();\n      });\n      window['walker'].update();\n      window['walker'].show();\n      iteration++;\n    } else if (active && window['generation'] > maxGenerations) {\n      p.textSize(44);\n      p.textAlign(p.CENTER, p.CENTER);\n      p.fill(255);\n      p.text('Complete', WIDTH / 2, HEIGHT / 2);\n      p.noLoop();\n    } else {\n      p.textSize(44);\n      p.textAlign(p.CENTER, p.CENTER);\n      p.fill(255);\n      p.text('Paused', WIDTH / 2, HEIGHT / 2);\n      p.noLoop();\n    }\n  };\n\n  p.myCustomRedrawAccordingToNewPropsHandler = function (props) {\n    if (props.hasOwnProperty(\"status\")) {\n      active = props.status;\n    }\n\n    if (props.hasOwnProperty(\"initNeat\")) {\n      initNeat = props.initNeat;\n    }\n\n    if (props.hasOwnProperty(\"startEvaluation\")) {\n      startEvaluation = props.startEvaluation;\n    }\n\n    if (props.hasOwnProperty(\"endEvaluation\")) {\n      endEvaluation = props.endEvaluation;\n    }\n\n    if (props.hasOwnProperty(\"width\")) {\n      WIDTH = props.width;\n    }\n\n    if (props.hasOwnProperty(\"height\")) {\n      HEIGHT = props.height;\n    }\n\n    if (props.hasOwnProperty(\"iterations\")) {\n      iterations = props.iterations;\n    }\n\n    if (props.hasOwnProperty(\"width\")) {\n      WIDTH = props.width;\n    }\n\n    if (props.hasOwnProperty(\"height\")) {\n      HEIGHT = props.height;\n    }\n\n    if (props.hasOwnProperty(\"maxGenerations\")) {\n      maxGenerations = props.maxGenerations;\n    }\n  }; //-----------------------------------------------------------\n\n  /**\n   * Draw a square grid with grey lines\n   */\n\n\n  p.squareGrid = function () {\n    p.stroke(204, 204, 204, 160);\n    p.strokeWeight(1);\n\n    for (var x = 0; x <= WIDTH / 20; x++) {\n      p.line(x * 20 + 20, 0, x * 20 + 20, HEIGHT);\n    }\n\n    for (var y = 0; y <= HEIGHT / 20; y++) {\n      p.line(0, y * 20 + 20, WIDTH, y * 20 + 20);\n    }\n\n    p.fill(255, 255, 255, 100);\n    p.rect(0, 0, WIDTH, HEIGHT);\n    p.noStroke();\n  };\n  /**\n   * Calculate distance between two points\n   */\n\n\n  p.distance = function (x1, y1, x2, y2) {\n    var dx = x1 - x2;\n    var dy = y1 - y2;\n    return Math.sqrt(dx * dx + dy * dy);\n  };\n  /**\n   * Get a relative color between red and green\n   */\n\n\n  p.activationColor = function (value, max) {\n    var power = 1 - Math.min(value / max, 1);\n    var color = [255, 255, 0];\n\n    if (power < 0.5) {\n      color[0] = 2 * power * 255;\n    } else {\n      color[1] = (1.0 - 2 * (power - 0.5)) * 255;\n    }\n\n    return color;\n  };\n  /**\n   * Get the angle from one point to another\n   */\n\n\n  p.angleToPoint = function (x1, y1, x2, y2) {\n    var d = this.distance(x1, y1, x2, y2);\n    var dx = (x2 - x1) / d;\n    var dy = (y2 - y1) / d;\n    var a = Math.acos(dx);\n    a = dy < 0 ? 2 * Math.PI - a : a;\n    return a;\n  };\n}\n\n//# sourceURL=webpack:///./assets/js/sketches/index.js?");

/***/ }),

/***/ "./assets/scss/app.scss":
/*!******************************!*\
  !*** ./assets/scss/app.scss ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// extracted by mini-css-extract-plugin\n\n//# sourceURL=webpack:///./assets/scss/app.scss?");

/***/ }),

/***/ 0:
/*!**********************************************************************!*\
  !*** multi babel-polyfill ./assets/js/app.js ./assets/scss/app.scss ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! babel-polyfill */\"./node_modules/babel-polyfill/lib/index.js\");\n__webpack_require__(/*! /Users/rhys/Desktop/Projects/git-repositories/HPOExperiment/resources/assets/js/app.js */\"./assets/js/app.js\");\nmodule.exports = __webpack_require__(/*! /Users/rhys/Desktop/Projects/git-repositories/HPOExperiment/resources/assets/scss/app.scss */\"./assets/scss/app.scss\");\n\n\n//# sourceURL=webpack:///multi_babel-polyfill_./assets/js/app.js_./assets/scss/app.scss?");

/***/ })

/******/ });